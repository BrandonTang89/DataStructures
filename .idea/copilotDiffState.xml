<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/CMakeLists.txt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/CMakeLists.txt" />
              <option name="originalContent" value="cmake_minimum_required(VERSION 3.31.6)&#10;project(DataStructures)&#10;&#10;set(CMAKE_CXX_STANDARD 26)&#10;set(CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -fsanitize=address,undefined -fno-omit-frame-pointer&quot;)&#10;set(CMAKE_LINKER_FLAGS &quot;${CMAKE_LINKER_FLAGS} -fsanitize=address,undefined&quot;)&#10;&#10;find_package(Catch2)&#10;&#10;add_executable(DataStructures main.cpp&#10;        CachingAllocator.h)&#10;&#10;add_executable(tests&#10;        test_circular_buffer.cpp&#10;        test_deque.cpp&#10;        TestingTracker.h)&#10;target_link_libraries(tests PRIVATE Catch2::Catch2WithMain)&#10;enable_testing()&#10;add_test(NAME CircularBufferTests COMMAND tests)" />
              <option name="updatedContent" value="cmake_minimum_required(VERSION 3.31.6)&#10;project(DataStructures)&#10;&#10;set(CMAKE_CXX_STANDARD 26)&#10;set(CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -fsanitize=address,undefined -fno-omit-frame-pointer&quot;)&#10;set(CMAKE_LINKER_FLAGS &quot;${CMAKE_LINKER_FLAGS} -fsanitize=address,undefined&quot;)&#10;&#10;find_package(Catch2)&#10;&#10;add_executable(DataStructures main.cpp&#10;        CachingAllocator.h)&#10;&#10;add_executable(tests&#10;        test_circular_buffer.cpp&#10;        test_deque.cpp&#10;        TestingTracker.h&#10;        TestingTracker.cpp)&#10;target_link_libraries(tests PRIVATE Catch2::Catch2WithMain)&#10;enable_testing()&#10;add_test(NAME CircularBufferTests COMMAND tests)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Deque.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Deque.h" />
              <option name="originalContent" value="/// A Double Ended Queue (Deque)&#10;&#10;#pragma once&#10;&#10;#include &lt;algorithm&gt;&#10;#include &lt;array&gt;&#10;#include &lt;cassert&gt;&#10;#include &lt;cstddef&gt;&#10;#include &lt;memory&gt;&#10;&#10;#include &quot;CircularBuffer.h&quot;&#10;#include &quot;CachingAllocator.h&quot;&#10;&#10;template&lt;typename T&gt;&#10;class Deque {&#10;    static constexpr size_t fixed_arr_n_elem = std::max((4096 + sizeof(T) - 1) / sizeof(T), 16zu);&#10;&#10;    struct alignas(4096) FixedArray {&#10;        // Page aligned&#10;        std::array&lt;std::byte, fixed_arr_n_elem * sizeof(T)&gt; data_storage{};&#10;        T *data{reinterpret_cast&lt;T *&gt;(data_storage.data())};&#10;        FixedArray *next{nullptr};&#10;        FixedArray *prev{nullptr};&#10;&#10;        template&lt;class Self&gt;&#10;        auto &amp;&amp;operator[](this Self &amp;&amp;self, size_t index) {&#10;            assert(index &lt; fixed_arr_n_elem &amp;&amp; &quot;Index out of bounds&quot;);&#10;            return self.data[index];&#10;        }&#10;    };&#10;&#10;    CachingAllocator&lt;FixedArray&gt; allocator{5};&#10;    CircularBuffer&lt;std::unique_ptr&lt;FixedArray, CachingAllocator&lt;FixedArray&gt; &amp;&gt; &gt; buffer{};&#10;    // Implicitly, these are on the first and last FixedArray, which may be the same&#10;    size_t first_idx = 0; // inv: 0 &lt;= first_idx &lt; fixed_arr_n_elem&#10;    size_t last_idx = 0; // inv: 0 &lt; last_idx &lt;= fixed_arr_n_elem&#10;    size_t size_{0};&#10;&#10;    template&lt;typename... Args&gt;&#10;    void emplace_front_impl(Args &amp;&amp;... value) {&#10;        if (first_idx == 0) [[unlikely]] {&#10;            FixedArray *first_array_ptr = buffer.front().get();&#10;            buffer.push_front(allocator.allocate());&#10;            buffer.front()-&gt;next = first_array_ptr;&#10;            first_array_ptr-&gt;prev = buffer.front().get();&#10;            first_idx = fixed_arr_n_elem;&#10;        }&#10;        FixedArray &amp;first_array = *buffer.front();&#10;        --first_idx;&#10;        new(&amp;first_array[first_idx]) T(std::forward&lt;Args&gt;(value)...);&#10;        ++size_;&#10;    }&#10;&#10;    template&lt;typename... Args&gt;&#10;    void emplace_back_impl(Args &amp;&amp;... value) {&#10;        if (last_idx == fixed_arr_n_elem) [[unlikely]] {&#10;            FixedArray *last_array_ptr = buffer.back().get();&#10;            buffer.push_back(allocator.allocate());&#10;            buffer.back()-&gt;prev = last_array_ptr;&#10;            last_array_ptr-&gt;next = buffer.back().get();&#10;            last_idx = 0;&#10;        }&#10;        FixedArray &amp;last_array = *buffer.back();&#10;        new(&amp;last_array[last_idx]) T(std::forward&lt;Args&gt;(value)...);&#10;        ++last_idx;&#10;        ++size_;&#10;    }&#10;&#10;    struct Iterator {&#10;        Deque *deque{};&#10;        FixedArray *current_array{};&#10;        size_t index{};&#10;&#10;        T &amp;operator*() {&#10;            return current_array-&gt;data[index];&#10;        }&#10;&#10;        [[nodiscard]] Iterator next() const {&#10;            if (current_array == nullptr) [[unlikely]] {&#10;                return *this; // Already at end&#10;            }&#10;            if (index == deque-&gt;last_idx - 1 &amp;&amp; current_array == deque-&gt;buffer.back().get()) [[unlikely]] {&#10;                return Iterator{deque, nullptr, 0}; // Move to end&#10;            }&#10;&#10;            if (index == fixed_arr_n_elem - 1) {&#10;                return Iterator{deque, current_array-&gt;next, 0}; // Move to next array&#10;            }&#10;&#10;&#10;            return Iterator{deque, current_array, index + 1};&#10;        }&#10;&#10;        [[nodiscard]] Iterator prev() const {&#10;            if (current_array == nullptr) {&#10;                // Coming from end, go to last valid element&#10;                return Iterator{deque, deque-&gt;buffer.back().get(), deque-&gt;last_idx - 1};&#10;            }&#10;&#10;            // Check if we're at the first element of the deque&#10;            if (current_array == deque-&gt;buffer.front().get() &amp;&amp; index == deque-&gt;first_idx) {&#10;                return Iterator{deque, nullptr, 0}; // Before begin (invalid)&#10;            }&#10;&#10;            // Move to previous position in current array&#10;            if (index &gt; 0) {&#10;                return Iterator{deque, current_array, index - 1};&#10;            }&#10;&#10;            // Move to previous array&#10;            return Iterator{deque, current_array-&gt;prev, fixed_arr_n_elem - 1};&#10;        }&#10;&#10;        Iterator &amp;operator++() {&#10;            *this = next();&#10;            return *this;&#10;        }&#10;&#10;        Iterator operator++(int) {&#10;            Iterator temp = *this;&#10;            ++(*this);&#10;            return temp;&#10;        }&#10;&#10;        Iterator &amp;operator--() {&#10;            *this = prev();&#10;            return *this;&#10;        }&#10;&#10;        Iterator operator--(int) {&#10;            Iterator temp = *this;&#10;            --(*this);&#10;            return temp;&#10;        }&#10;&#10;        // Equality operators needed for range-based for loops&#10;        bool operator==(const Iterator &amp;other) const {&#10;            return deque == other.deque &amp;&amp;&#10;                   current_array == other.current_array &amp;&amp;&#10;                   index == other.index;&#10;        }&#10;&#10;        bool operator!=(const Iterator &amp;other) const {&#10;            return !(*this == other);&#10;        }&#10;    };&#10;&#10;public:&#10;    Deque() {&#10;        buffer.push_back(allocator.allocate());&#10;    }&#10;&#10;    Deque(std::initializer_list&lt;T&gt; init) {&#10;        buffer.push_back(allocator.allocate());&#10;        for (const auto &amp;value: init) {&#10;            emplace_back_impl(value);&#10;        }&#10;    }&#10;&#10;    // Rule of 5 Methods&#10;    ~Deque() {&#10;        for (T&amp; item: *this) {&#10;            item.~T(); // Explicitly call destructor for each element&#10;        }&#10;    }&#10;&#10;    Deque(const Deque &amp;other) = delete;&#10;    Deque &amp;operator=(const Deque &amp;other) = delete;&#10;    Deque(Deque &amp;&amp;other) noexcept&#10;        : allocator(std::move(other.allocator)), buffer(std::move(other.buffer)),&#10;          first_idx(other.first_idx), last_idx(other.last_idx), size_(other.size_) {&#10;        other.first_idx = 0;&#10;        other.last_idx = 0;&#10;        other.size_ = 0;&#10;    }&#10;&#10;    Deque &amp;operator=(Deque &amp;&amp;other) noexcept {&#10;        if (this != &amp;other) {&#10;            // Properly destroy existing elements&#10;            for (T&amp; item: *this) {&#10;                item.~T();&#10;            }&#10;&#10;            // Since CachingAllocator and CircularBuffer don't have proper move assignment,&#10;            // we need to reconstruct this object using the move constructor approach&#10;            this-&gt;~Deque(); // Properly destroy this object&#10;            &#10;            // Use placement new to reconstruct using move constructor&#10;            new (this) Deque(std::move(other));&#10;        }&#10;        return *this;&#10;    }&#10;&#10;&#10;    void push_back(const T &amp;value) requires std::copy_constructible&lt;T&gt; {&#10;        emplace_back_impl(value);&#10;    }&#10;&#10;    void push_back(T &amp;&amp;value) requires std::move_constructible&lt;T&gt; {&#10;        emplace_back_impl(std::move(value));&#10;    }&#10;&#10;    template&lt;typename... Args&gt;&#10;    void emplace_back(Args &amp;&amp;... args) requires std::constructible_from&lt;T, Args...&gt; {&#10;        emplace_back_impl(std::forward&lt;Args&gt;(args)...);&#10;    }&#10;&#10;    void push_front(const T &amp;value) requires std::copy_constructible&lt;T&gt; {&#10;        emplace_front_impl(value);&#10;    }&#10;&#10;    void push_front(T &amp;&amp;value) requires std::move_constructible&lt;T&gt; {&#10;        emplace_front_impl(std::move(value));&#10;    }&#10;&#10;    template&lt;typename... Args&gt;&#10;    void emplace_front(Args &amp;&amp;... args) requires std::constructible_from&lt;T, Args...&gt; {&#10;        emplace_front_impl(std::forward&lt;Args&gt;(args)...);&#10;    }&#10;&#10;    T pop_back() {&#10;        assert(size_ &gt; 0 &amp;&amp; &quot;Cannot pop from an empty deque&quot;);&#10;        --size_;&#10;        --last_idx;&#10;        FixedArray &amp;last_array = *buffer.back();&#10;        T value = std::move(last_array[last_idx]);&#10;        if (last_idx == 0) [[unlikely]] {&#10;            // Remove the last FixedArray if it is empty&#10;            buffer.pop_back();&#10;            last_idx = fixed_arr_n_elem;&#10;        }&#10;        return value;&#10;    }&#10;&#10;    T pop_front() {&#10;        assert(size_ &gt; 0 &amp;&amp; &quot;Cannot pop from an empty deque&quot;);&#10;        --size_;&#10;        FixedArray &amp;first_array = *buffer.front();&#10;        T value = std::move(first_array[first_idx]);&#10;        ++first_idx;&#10;        if (first_idx == fixed_arr_n_elem) [[unlikely]] {&#10;            // Remove the first FixedArray if it is empty&#10;            buffer.pop_front();&#10;            first_idx = 0; // Reset to the start of the next FixedArray&#10;        }&#10;        return value;&#10;    }&#10;&#10;    template&lt;class Self&gt;&#10;    auto &amp;&amp;operator[](this Self &amp;&amp;self, const size_t index) {&#10;        assert(index &lt; self.size_ &amp;&amp; &quot;Index out of bounds&quot;);&#10;&#10;        const size_t first_size = fixed_arr_n_elem - self.first_idx;&#10;        if (index &lt; first_size) {&#10;            // Access within the first FixedArray&#10;            return (*self.buffer.front())[self.first_idx + index];&#10;        }&#10;&#10;        const size_t adjusted_index = index - first_size;&#10;        const size_t num_full_arrays = adjusted_index / fixed_arr_n_elem;&#10;        const size_t index_in_array = adjusted_index % fixed_arr_n_elem;&#10;        return (*self.buffer[num_full_arrays + 1])[index_in_array];&#10;    }&#10;&#10;    template&lt;typename Self&gt;&#10;    auto &amp;&amp;back(this Self &amp;&amp;self) {&#10;        assert(self.size_ &gt; 0 &amp;&amp; &quot;Deque is empty&quot;);&#10;        return (*self.buffer.back())[self.last_idx - 1];&#10;    }&#10;&#10;    template&lt;typename Self&gt;&#10;    auto &amp;&amp;front(this Self &amp;&amp;self) {&#10;        assert(self.size_ &gt; 0 &amp;&amp; &quot;Deque is empty&quot;);&#10;        return (*self.buffer.front())[self.first_idx];&#10;    }&#10;&#10;    Iterator end() {&#10;        return Iterator{this, nullptr, 0}; // End of iteration&#10;    }&#10;&#10;    Iterator begin() {&#10;        if (size_ == 0) [[unlikely]] {&#10;            return end(); // Empty deque&#10;        }&#10;        return Iterator{this, buffer.front().get(), first_idx};&#10;    }&#10;&#10;    [[nodiscard]] size_t size() const {&#10;        return size_;&#10;    }&#10;&#10;    [[nodiscard]] bool empty() const {&#10;        return size_ == 0;&#10;    }&#10;};&#10;&#10;// Explicit template instantiations for common types&#10;template class Deque&lt;int&gt;;&#10;template class Deque&lt;std::string&gt;;&#10;" />
              <option name="updatedContent" value="/// A Double Ended Queue (Deque)&#10;&#10;#pragma once&#10;&#10;#include &lt;algorithm&gt;&#10;#include &lt;array&gt;&#10;#include &lt;cassert&gt;&#10;#include &lt;cstddef&gt;&#10;#include &lt;memory&gt;&#10;&#10;#include &quot;CircularBuffer.h&quot;&#10;#include &quot;CachingAllocator.h&quot;&#10;&#10;template&lt;typename T&gt;&#10;class Deque {&#10;    static constexpr size_t fixed_arr_n_elem = std::max((4096 + sizeof(T) - 1) / sizeof(T), 16zu);&#10;&#10;    struct alignas(4096) FixedArray {&#10;        // Page aligned&#10;        std::array&lt;std::byte, fixed_arr_n_elem * sizeof(T)&gt; data_storage{};&#10;        T *data{reinterpret_cast&lt;T *&gt;(data_storage.data())};&#10;        FixedArray *next{nullptr};&#10;        FixedArray *prev{nullptr};&#10;&#10;        template&lt;class Self&gt;&#10;        auto &amp;&amp;operator[](this Self &amp;&amp;self, size_t index) {&#10;            assert(index &lt; fixed_arr_n_elem &amp;&amp; &quot;Index out of bounds&quot;);&#10;            return self.data[index];&#10;        }&#10;    };&#10;&#10;    CachingAllocator&lt;FixedArray&gt; allocator{5};&#10;    CircularBuffer&lt;std::unique_ptr&lt;FixedArray, CachingAllocator&lt;FixedArray&gt; &amp;&gt; &gt; buffer{};&#10;    // Implicitly, these are on the first and last FixedArray, which may be the same&#10;    size_t first_idx = 0; // inv: 0 &lt;= first_idx &lt; fixed_arr_n_elem&#10;    size_t last_idx = 0; // inv: 0 &lt; last_idx &lt;= fixed_arr_n_elem&#10;    size_t size_{0};&#10;&#10;    template&lt;typename... Args&gt;&#10;    void emplace_front_impl(Args &amp;&amp;... value) {&#10;        if (first_idx == 0) [[unlikely]] {&#10;            FixedArray *first_array_ptr = buffer.front().get();&#10;            buffer.push_front(allocator.allocate());&#10;            buffer.front()-&gt;next = first_array_ptr;&#10;            first_array_ptr-&gt;prev = buffer.front().get();&#10;            first_idx = fixed_arr_n_elem;&#10;        }&#10;        FixedArray &amp;first_array = *buffer.front();&#10;        --first_idx;&#10;        new(&amp;first_array[first_idx]) T(std::forward&lt;Args&gt;(value)...);&#10;        ++size_;&#10;    }&#10;&#10;    template&lt;typename... Args&gt;&#10;    void emplace_back_impl(Args &amp;&amp;... value) {&#10;        if (last_idx == fixed_arr_n_elem) [[unlikely]] {&#10;            FixedArray *last_array_ptr = buffer.back().get();&#10;            buffer.push_back(allocator.allocate());&#10;            buffer.back()-&gt;prev = last_array_ptr;&#10;            last_array_ptr-&gt;next = buffer.back().get();&#10;            last_idx = 0;&#10;        }&#10;        FixedArray &amp;last_array = *buffer.back();&#10;        new(&amp;last_array[last_idx]) T(std::forward&lt;Args&gt;(value)...);&#10;        ++last_idx;&#10;        ++size_;&#10;    }&#10;&#10;    struct Iterator {&#10;        Deque *deque{};&#10;        FixedArray *current_array{};&#10;        size_t index{};&#10;&#10;        T &amp;operator*() {&#10;            return current_array-&gt;data[index];&#10;        }&#10;&#10;        [[nodiscard]] Iterator next() const {&#10;            if (current_array == nullptr) [[unlikely]] {&#10;                return *this; // Already at end&#10;            }&#10;            if (index == deque-&gt;last_idx - 1 &amp;&amp; current_array == deque-&gt;buffer.back().get()) [[unlikely]] {&#10;                return Iterator{deque, nullptr, 0}; // Move to end&#10;            }&#10;&#10;            if (index == fixed_arr_n_elem - 1) {&#10;                return Iterator{deque, current_array-&gt;next, 0}; // Move to next array&#10;            }&#10;&#10;&#10;            return Iterator{deque, current_array, index + 1};&#10;        }&#10;&#10;        [[nodiscard]] Iterator prev() const {&#10;            if (current_array == nullptr) {&#10;                // Coming from end, go to last valid element&#10;                return Iterator{deque, deque-&gt;buffer.back().get(), deque-&gt;last_idx - 1};&#10;            }&#10;&#10;            // Check if we're at the first element of the deque&#10;            if (current_array == deque-&gt;buffer.front().get() &amp;&amp; index == deque-&gt;first_idx) {&#10;                return Iterator{deque, nullptr, 0}; // Before begin (invalid)&#10;            }&#10;&#10;            // Move to previous position in current array&#10;            if (index &gt; 0) {&#10;                return Iterator{deque, current_array, index - 1};&#10;            }&#10;&#10;            // Move to previous array&#10;            return Iterator{deque, current_array-&gt;prev, fixed_arr_n_elem - 1};&#10;        }&#10;&#10;        Iterator &amp;operator++() {&#10;            *this = next();&#10;            return *this;&#10;        }&#10;&#10;        Iterator operator++(int) {&#10;            Iterator temp = *this;&#10;            ++(*this);&#10;            return temp;&#10;        }&#10;&#10;        Iterator &amp;operator--() {&#10;            *this = prev();&#10;            return *this;&#10;        }&#10;&#10;        Iterator operator--(int) {&#10;            Iterator temp = *this;&#10;            --(*this);&#10;            return temp;&#10;        }&#10;&#10;        // Equality operators needed for range-based for loops&#10;        bool operator==(const Iterator &amp;other) const {&#10;            return deque == other.deque &amp;&amp;&#10;                   current_array == other.current_array &amp;&amp;&#10;                   index == other.index;&#10;        }&#10;&#10;        bool operator!=(const Iterator &amp;other) const {&#10;            return !(*this == other);&#10;        }&#10;    };&#10;&#10;public:&#10;    Deque() {&#10;        buffer.push_back(allocator.allocate());&#10;    }&#10;&#10;    Deque(std::initializer_list&lt;T&gt; init) {&#10;        buffer.push_back(allocator.allocate());&#10;        for (const auto &amp;value: init) {&#10;            emplace_back_impl(value);&#10;        }&#10;    }&#10;&#10;    // Rule of 5 Methods&#10;    ~Deque() {&#10;        for (T&amp; item: *this) {&#10;            item.~T(); // Explicitly call destructor for each element&#10;        }&#10;    }&#10;&#10;    Deque(const Deque &amp;other) = delete;&#10;    Deque &amp;operator=(const Deque &amp;other) = delete;&#10;    Deque(Deque &amp;&amp;other) noexcept&#10;        : allocator(std::move(other.allocator)), buffer(std::move(other.buffer)),&#10;          first_idx(other.first_idx), last_idx(other.last_idx), size_(other.size_) {&#10;        other.first_idx = 0;&#10;        other.last_idx = 0;&#10;        other.size_ = 0;&#10;    }&#10;&#10;    Deque &amp;operator=(Deque &amp;&amp;other) noexcept {&#10;        if (this != &amp;other) {&#10;            // Properly destroy existing elements&#10;            for (T&amp; item: *this) {&#10;                item.~T();&#10;            }&#10;&#10;            // Since CachingAllocator and CircularBuffer don't have proper move assignment,&#10;            // we need to reconstruct this object using the move constructor approach&#10;            this-&gt;~Deque(); // Properly destroy this object&#10;            &#10;            // Use placement new to reconstruct using move constructor&#10;            new (this) Deque(std::move(other));&#10;        }&#10;        return *this;&#10;    }&#10;&#10;&#10;    void push_back(const T &amp;value) requires std::copy_constructible&lt;T&gt; {&#10;        emplace_back_impl(value);&#10;    }&#10;&#10;    void push_back(T &amp;&amp;value) requires std::move_constructible&lt;T&gt; {&#10;        emplace_back_impl(std::move(value));&#10;    }&#10;&#10;    template&lt;typename... Args&gt;&#10;    void emplace_back(Args &amp;&amp;... args) requires std::constructible_from&lt;T, Args...&gt; {&#10;        emplace_back_impl(std::forward&lt;Args&gt;(args)...);&#10;    }&#10;&#10;    void push_front(const T &amp;value) requires std::copy_constructible&lt;T&gt; {&#10;        emplace_front_impl(value);&#10;    }&#10;&#10;    void push_front(T &amp;&amp;value) requires std::move_constructible&lt;T&gt; {&#10;        emplace_front_impl(std::move(value));&#10;    }&#10;&#10;    template&lt;typename... Args&gt;&#10;    void emplace_front(Args &amp;&amp;... args) requires std::constructible_from&lt;T, Args...&gt; {&#10;        emplace_front_impl(std::forward&lt;Args&gt;(args)...);&#10;    }&#10;&#10;    T pop_back() {&#10;        assert(size_ &gt; 0 &amp;&amp; &quot;Cannot pop from an empty deque&quot;);&#10;        --size_;&#10;        --last_idx;&#10;        FixedArray &amp;last_array = *buffer.back();&#10;        T value = std::move(last_array[last_idx]);&#10;        if (last_idx == 0) [[unlikely]] {&#10;            // Remove the last FixedArray if it is empty&#10;            buffer.pop_back();&#10;            last_idx = fixed_arr_n_elem;&#10;        }&#10;        return value;&#10;    }&#10;&#10;    T pop_front() {&#10;        assert(size_ &gt; 0 &amp;&amp; &quot;Cannot pop from an empty deque&quot;);&#10;        --size_;&#10;        FixedArray &amp;first_array = *buffer.front();&#10;        T value = std::move(first_array[first_idx]);&#10;        ++first_idx;&#10;        if (first_idx == fixed_arr_n_elem) [[unlikely]] {&#10;            // Remove the first FixedArray if it is empty&#10;            buffer.pop_front();&#10;            first_idx = 0; // Reset to the start of the next FixedArray&#10;        }&#10;        return value;&#10;    }&#10;&#10;    template&lt;class Self&gt;&#10;    auto &amp;&amp;operator[](this Self &amp;&amp;self, const size_t index) {&#10;        assert(index &lt; self.size_ &amp;&amp; &quot;Index out of bounds&quot;);&#10;&#10;        const size_t first_size = fixed_arr_n_elem - self.first_idx;&#10;        if (index &lt; first_size) {&#10;            // Access within the first FixedArray&#10;            return (*self.buffer.front())[self.first_idx + index];&#10;        }&#10;&#10;        const size_t adjusted_index = index - first_size;&#10;        const size_t num_full_arrays = adjusted_index / fixed_arr_n_elem;&#10;        const size_t index_in_array = adjusted_index % fixed_arr_n_elem;&#10;        return (*self.buffer[num_full_arrays + 1])[index_in_array];&#10;    }&#10;&#10;    template&lt;typename Self&gt;&#10;    auto &amp;&amp;back(this Self &amp;&amp;self) {&#10;        assert(self.size_ &gt; 0 &amp;&amp; &quot;Deque is empty&quot;);&#10;        return (*self.buffer.back())[self.last_idx - 1];&#10;    }&#10;&#10;    template&lt;typename Self&gt;&#10;    auto &amp;&amp;front(this Self &amp;&amp;self) {&#10;        assert(self.size_ &gt; 0 &amp;&amp; &quot;Deque is empty&quot;);&#10;        return (*self.buffer.front())[self.first_idx];&#10;    }&#10;&#10;    Iterator end() {&#10;        return Iterator{this, nullptr, 0}; // End of iteration&#10;    }&#10;&#10;    Iterator begin() {&#10;        if (size_ == 0) [[unlikely]] {&#10;            return end(); // Empty deque&#10;        }&#10;        return Iterator{this, buffer.front().get(), first_idx};&#10;    }&#10;&#10;    [[nodiscard]] size_t size() const {&#10;        return size_;&#10;    }&#10;&#10;    [[nodiscard]] bool empty() const {&#10;        return size_ == 0;&#10;    }&#10;};&#10;&#10;// Explicit template instantiations for common types&#10;template class Deque&lt;int&gt;;&#10;template class Deque&lt;std::string&gt;;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/TestingTracker.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/TestingTracker.cpp" />
              <option name="updatedContent" value="#include &quot;TestingTracker.h&quot;&#10;&#10;int TestingTracker::constructed = 0;&#10;int TestingTracker::destructed = 0;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/TestingTracker.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/TestingTracker.h" />
              <option name="originalContent" value="#pragma once&#10;class TestingTracker {&#10;public:&#10;    static int constructed;&#10;    static int destructed;&#10;&#10;    TestingTracker() {&#10;        constructed++;&#10;    }&#10;&#10;    TestingTracker(const TestingTracker &amp;) {&#10;        constructed++;&#10;    }&#10;&#10;    ~TestingTracker() {&#10;        destructed++;&#10;    }&#10;};&#10;&#10;int TestingTracker::constructed = 0;&#10;int TestingTracker::destructed = 0;&#10;" />
              <option name="updatedContent" value="#pragma once&#10;class TestingTracker {&#10;public:&#10;    static int constructed;&#10;    static int destructed;&#10;&#10;    TestingTracker() {&#10;        constructed++;&#10;    }&#10;&#10;    TestingTracker(const TestingTracker &amp;) {&#10;        constructed++;&#10;    }&#10;&#10;    ~TestingTracker() {&#10;        destructed++;&#10;    }&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/test_circular_buffer.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/test_circular_buffer.cpp" />
              <option name="originalContent" value="#include &lt;catch2/catch_test_macros.hpp&gt;&#10;#include &quot;CircularBuffer.h&quot;&#10;#include &quot;TestingTracker.h&quot;&#10;&#10;TEST_CASE(&quot;CircularBuffer construction&quot;, &quot;[CircularBuffer]&quot;) {&#10;    SECTION(&quot;Create buffer with capacity&quot;) {&#10;        CircularBuffer&lt;int&gt; buffer{100};&#10;        REQUIRE(true); // Constructor should not throw&#10;    }&#10;}&#10;&#10;TEST_CASE(&quot;CircularBuffer push_back&quot;, &quot;[CircularBuffer]&quot;) {&#10;    CircularBuffer&lt;int&gt; buffer(3);&#10;&#10;    SECTION(&quot;Push elements within capacity&quot;) {&#10;        REQUIRE_NOTHROW(buffer.push_back(1));&#10;        REQUIRE_NOTHROW(buffer.push_back(2));&#10;        REQUIRE_NOTHROW(buffer.push_back(3));&#10;        REQUIRE(buffer.size() == 3);&#10;    }&#10;&#10;    SECTION(&quot;Push beyond capacity should resize&quot;) {&#10;        buffer.push_back(1);&#10;        buffer.push_back(2);&#10;        buffer.push_back(3);&#10;        buffer.push_back(4);&#10;&#10;        REQUIRE(buffer.size() == 4);&#10;    }&#10;}&#10;&#10;TEST_CASE(&quot;CircularBuffer with strings&quot;, &quot;[CircularBuffer]&quot;) {&#10;    CircularBuffer&lt;std::string&gt; buffer(2);&#10;&#10;    SECTION(&quot;Push string elements&quot;) {&#10;        REQUIRE_NOTHROW(buffer.push_back(&quot;hello&quot;));&#10;        REQUIRE_NOTHROW(buffer.push_back(&quot;world&quot;));&#10;        buffer.pop_back();&#10;        buffer.pop_back();&#10;    }&#10;}&#10;&#10;TEST_CASE(&quot;CircularBuffer resizing and operator[]&quot;, &quot;[CircularBuffer]&quot;) {&#10;    CircularBuffer&lt;int&gt; buffer(4);&#10;&#10;    SECTION(&quot;Upward resizing maintains order and size&quot;) {&#10;        for (int i = 0; i &lt; 20; ++i) {&#10;            buffer.push_back(i);&#10;        }&#10;        REQUIRE(buffer.size() == 20);&#10;        for (int i = 0; i &lt; 20; ++i) {&#10;            REQUIRE(buffer[i] == i);&#10;        }&#10;        REQUIRE(buffer.capacity() &gt;= 20);&#10;    }&#10;&#10;    SECTION(&quot;Downward resizing maintains order and size&quot;) {&#10;        for (int i = 0; i &lt; 32; ++i) {&#10;            buffer.push_back(i);&#10;        }&#10;        for (int i = 0; i &lt; 28; ++i) {&#10;            buffer.pop_front();&#10;        }&#10;        REQUIRE(buffer.size() == 4);&#10;        for (int i = 0; i &lt; 4; ++i) {&#10;            REQUIRE(buffer[i] == 28 + i);&#10;        }&#10;        REQUIRE(buffer.capacity() &lt;= 32);&#10;    }&#10;&#10;    SECTION(&quot;operator[] works after wraparound and resize&quot;) {&#10;        for (int i = 0; i &lt; 8; ++i) {&#10;            buffer.push_back(i);&#10;        }&#10;        for (int i = 0; i &lt; 4; ++i) {&#10;            buffer.pop_front();&#10;        }&#10;        for (int i = 8; i &lt; 12; ++i) {&#10;            buffer.push_back(i);&#10;        }&#10;        // Buffer now contains 4..11&#10;        for (int i = 0; i &lt; buffer.size(); ++i) {&#10;            REQUIRE(buffer[i] == 4 + i);&#10;        }&#10;    }&#10;}&#10;&#10;TEST_CASE(&quot;CircularBuffer robustness tests&quot;, &quot;[CircularBuffer][Robustness]&quot;) {&#10;    SECTION(&quot;Multiple upward resizes maintain correctness&quot;) {&#10;        CircularBuffer&lt;int&gt; buffer(8);&#10;&#10;        // Fill buffer to trigger multiple resizes&#10;        for (int i = 0; i &lt; 1000; ++i) {&#10;            buffer.push_back(i);&#10;        }&#10;&#10;        REQUIRE(buffer.size() == 1000);&#10;        REQUIRE(buffer.capacity() &gt;= 1000);&#10;&#10;        // Verify all elements are correct and accessible&#10;        for (int i = 0; i &lt; 1000; ++i) {&#10;            REQUIRE(buffer[i] == i);&#10;        }&#10;&#10;        // Verify front and back work correctly&#10;        REQUIRE(buffer.front() == 0);&#10;        REQUIRE(buffer.back() == 999);&#10;    }&#10;&#10;    SECTION(&quot;Multiple downward resizes maintain correctness&quot;) {&#10;        CircularBuffer&lt;int&gt; buffer(8);&#10;&#10;        // Fill buffer with many elements&#10;        for (int i = 0; i &lt; 1000; ++i) {&#10;            buffer.push_back(i);&#10;        }&#10;&#10;        // Remove most elements to trigger downward resizing&#10;        for (int i = 0; i &lt; 990; ++i) {&#10;            buffer.pop_front();&#10;        }&#10;&#10;        REQUIRE(buffer.size() == 10);&#10;        // Capacity should have decreased significantly&#10;        REQUIRE(buffer.capacity() &lt; 1000);&#10;&#10;        // Verify remaining elements are correct&#10;        for (int i = 0; i &lt; 10; ++i) {&#10;            REQUIRE(buffer[i] == 990 + i);&#10;        }&#10;&#10;        REQUIRE(buffer.front() == 990);&#10;        REQUIRE(buffer.back() == 999);&#10;    }&#10;&#10;    SECTION(&quot;Mixed operations with complex wraparound&quot;) {&#10;        CircularBuffer&lt;int&gt; buffer(16);&#10;&#10;        // Create complex pattern that causes wraparound&#10;        for (int cycle = 0; cycle &lt; 20; ++cycle) {&#10;            // Add elements&#10;            for (int i = 0; i &lt; 30; ++i) {&#10;                buffer.push_back(cycle * 100 + i);&#10;            }&#10;&#10;            // Remove some from front&#10;            for (int i = 0; i &lt; 15; ++i) {&#10;                buffer.pop_front();&#10;            }&#10;&#10;            // Add some to front&#10;            for (int i = 0; i &lt; 5; ++i) {&#10;                buffer.push_front(-(cycle * 100 + i + 1));&#10;            }&#10;&#10;            // Remove some from back&#10;            for (int i = 0; i &lt; 10; ++i) {&#10;                buffer.pop_back();&#10;            }&#10;        }&#10;&#10;        // Buffer should still be functional&#10;        REQUIRE(buffer.size() &gt; 0);&#10;&#10;        // operator[] should work for all valid indices&#10;        for (size_t i = 0; i &lt; buffer.size(); ++i) {&#10;            REQUIRE_NOTHROW(buffer[i]);&#10;        }&#10;&#10;        // front() and back() should work&#10;        REQUIRE_NOTHROW(buffer.front());&#10;        REQUIRE_NOTHROW(buffer.back());&#10;    }&#10;&#10;    SECTION(&quot;Size is maintained correctly through all operations&quot;) {&#10;        CircularBuffer&lt;int&gt; buffer(4);&#10;        size_t expected_size = 0;&#10;&#10;        // Push back operations&#10;        for (int i = 0; i &lt; 50; ++i) {&#10;            buffer.push_back(i);&#10;            ++expected_size;&#10;            REQUIRE(buffer.size() == expected_size);&#10;        }&#10;&#10;        // Push front operations&#10;        for (int i = 0; i &lt; 30; ++i) {&#10;            buffer.push_front(-i);&#10;            ++expected_size;&#10;            REQUIRE(buffer.size() == expected_size);&#10;        }&#10;&#10;        // Pop back operations&#10;        for (int i = 0; i &lt; 25; ++i) {&#10;            buffer.pop_back();&#10;            --expected_size;&#10;            REQUIRE(buffer.size() == expected_size);&#10;        }&#10;&#10;        // Pop front operations&#10;        for (int i = 0; i &lt; 25; ++i) {&#10;            buffer.pop_front();&#10;            --expected_size;&#10;            REQUIRE(buffer.size() == expected_size);&#10;        }&#10;&#10;        REQUIRE(expected_size == 30);&#10;        REQUIRE(buffer.size() == 30);&#10;    }&#10;&#10;    SECTION(&quot;operator[] correctness after resize operations&quot;) {&#10;        CircularBuffer&lt;int&gt; buffer(4);&#10;&#10;        // Fill with pattern&#10;        for (int i = 0; i &lt; 20; ++i) {&#10;            buffer.push_back(i * 3);  // 0, 3, 6, 9, 12, ...&#10;        }&#10;&#10;        // Verify pattern after upward resize&#10;        for (int i = 0; i &lt; 20; ++i) {&#10;            REQUIRE(buffer[i] == i * 3);&#10;        }&#10;&#10;        // Remove elements from front to trigger potential downward resize&#10;        for (int i = 0; i &lt; 15; ++i) {&#10;            buffer.pop_front();&#10;        }&#10;&#10;        // Verify remaining elements are still correct&#10;        REQUIRE(buffer.size() == 5);&#10;        for (int i = 0; i &lt; 5; ++i) {&#10;            REQUIRE(buffer[i] == (15 + i) * 3);  // Should be 45, 48, 51, 54, 57&#10;        }&#10;    }&#10;}&#10;&#10;TEST_CASE(&quot;CircularBuffer element construction/destruction count&quot;, &quot;[CircularBuffer][Lifetime]&quot;) {&#10;    TestingTracker::constructed = 0;&#10;    TestingTracker::destructed = 0;&#10;&#10;    constexpr int num_elements = 50;&#10;    {&#10;        CircularBuffer&lt;TestingTracker&gt; buffer(8);&#10;&#10;        // Add elements&#10;        for (int i = 0; i &lt; num_elements; ++i) {&#10;            buffer.emplace_back();&#10;        }&#10;        REQUIRE(TestingTracker::constructed == num_elements);&#10;        REQUIRE(buffer.size() == num_elements);&#10;&#10;        // Remove some elements&#10;        for (int i = 0; i &lt; 20; ++i) {&#10;            buffer.pop_front();&#10;        }&#10;        REQUIRE(TestingTracker::destructed == 20);&#10;        REQUIRE(buffer.size() == 30);&#10;&#10;    } // Buffer goes out of scope, remaining elements should be destructed&#10;    REQUIRE(TestingTracker::destructed == num_elements);&#10;}&#10;" />
              <option name="updatedContent" value="#include &lt;catch2/catch_test_macros.hpp&gt;&#10;#include &quot;CircularBuffer.h&quot;&#10;#include &quot;TestingTracker.h&quot;&#10;&#10;TEST_CASE(&quot;CircularBuffer construction&quot;, &quot;[CircularBuffer]&quot;) {&#10;    SECTION(&quot;Create buffer with capacity&quot;) {&#10;        CircularBuffer&lt;int&gt; buffer{100};&#10;        REQUIRE(true); // Constructor should not throw&#10;    }&#10;}&#10;&#10;TEST_CASE(&quot;CircularBuffer push_back&quot;, &quot;[CircularBuffer]&quot;) {&#10;    CircularBuffer&lt;int&gt; buffer(3);&#10;&#10;    SECTION(&quot;Push elements within capacity&quot;) {&#10;        REQUIRE_NOTHROW(buffer.push_back(1));&#10;        REQUIRE_NOTHROW(buffer.push_back(2));&#10;        REQUIRE_NOTHROW(buffer.push_back(3));&#10;        REQUIRE(buffer.size() == 3);&#10;    }&#10;&#10;    SECTION(&quot;Push beyond capacity should resize&quot;) {&#10;        buffer.push_back(1);&#10;        buffer.push_back(2);&#10;        buffer.push_back(3);&#10;        buffer.push_back(4);&#10;&#10;        REQUIRE(buffer.size() == 4);&#10;    }&#10;}&#10;&#10;TEST_CASE(&quot;CircularBuffer with strings&quot;, &quot;[CircularBuffer]&quot;) {&#10;    CircularBuffer&lt;std::string&gt; buffer(2);&#10;&#10;    SECTION(&quot;Push string elements&quot;) {&#10;        REQUIRE_NOTHROW(buffer.push_back(&quot;hello&quot;));&#10;        REQUIRE_NOTHROW(buffer.push_back(&quot;world&quot;));&#10;        buffer.pop_back();&#10;        buffer.pop_back();&#10;    }&#10;}&#10;&#10;TEST_CASE(&quot;CircularBuffer resizing and operator[]&quot;, &quot;[CircularBuffer]&quot;) {&#10;    CircularBuffer&lt;int&gt; buffer(4);&#10;&#10;    SECTION(&quot;Upward resizing maintains order and size&quot;) {&#10;        for (int i = 0; i &lt; 20; ++i) {&#10;            buffer.push_back(i);&#10;        }&#10;        REQUIRE(buffer.size() == 20);&#10;        for (int i = 0; i &lt; 20; ++i) {&#10;            REQUIRE(buffer[i] == i);&#10;        }&#10;        REQUIRE(buffer.capacity() &gt;= 20);&#10;    }&#10;&#10;    SECTION(&quot;Downward resizing maintains order and size&quot;) {&#10;        for (int i = 0; i &lt; 32; ++i) {&#10;            buffer.push_back(i);&#10;        }&#10;        for (int i = 0; i &lt; 28; ++i) {&#10;            buffer.pop_front();&#10;        }&#10;        REQUIRE(buffer.size() == 4);&#10;        for (int i = 0; i &lt; 4; ++i) {&#10;            REQUIRE(buffer[i] == 28 + i);&#10;        }&#10;        REQUIRE(buffer.capacity() &lt;= 32);&#10;    }&#10;&#10;    SECTION(&quot;operator[] works after wraparound and resize&quot;) {&#10;        for (int i = 0; i &lt; 8; ++i) {&#10;            buffer.push_back(i);&#10;        }&#10;        for (int i = 0; i &lt; 4; ++i) {&#10;            buffer.pop_front();&#10;        }&#10;        for (int i = 8; i &lt; 12; ++i) {&#10;            buffer.push_back(i);&#10;        }&#10;        // Buffer now contains 4..11&#10;        for (int i = 0; i &lt; buffer.size(); ++i) {&#10;            REQUIRE(buffer[i] == 4 + i);&#10;        }&#10;    }&#10;}&#10;&#10;TEST_CASE(&quot;CircularBuffer robustness tests&quot;, &quot;[CircularBuffer][Robustness]&quot;) {&#10;    SECTION(&quot;Multiple upward resizes maintain correctness&quot;) {&#10;        CircularBuffer&lt;int&gt; buffer(8);&#10;&#10;        // Fill buffer to trigger multiple resizes&#10;        for (int i = 0; i &lt; 1000; ++i) {&#10;            buffer.push_back(i);&#10;        }&#10;&#10;        REQUIRE(buffer.size() == 1000);&#10;        REQUIRE(buffer.capacity() &gt;= 1000);&#10;&#10;        // Verify all elements are correct and accessible&#10;        for (int i = 0; i &lt; 1000; ++i) {&#10;            REQUIRE(buffer[i] == i);&#10;        }&#10;&#10;        // Verify front and back work correctly&#10;        REQUIRE(buffer.front() == 0);&#10;        REQUIRE(buffer.back() == 999);&#10;    }&#10;&#10;    SECTION(&quot;Multiple downward resizes maintain correctness&quot;) {&#10;        CircularBuffer&lt;int&gt; buffer(8);&#10;&#10;        // Fill buffer with many elements&#10;        for (int i = 0; i &lt; 1000; ++i) {&#10;            buffer.push_back(i);&#10;        }&#10;&#10;        // Remove most elements to trigger downward resizing&#10;        for (int i = 0; i &lt; 990; ++i) {&#10;            buffer.pop_front();&#10;        }&#10;&#10;        REQUIRE(buffer.size() == 10);&#10;        // Capacity should have decreased significantly&#10;        REQUIRE(buffer.capacity() &lt; 1000);&#10;&#10;        // Verify remaining elements are correct&#10;        for (int i = 0; i &lt; 10; ++i) {&#10;            REQUIRE(buffer[i] == 990 + i);&#10;        }&#10;&#10;        REQUIRE(buffer.front() == 990);&#10;        REQUIRE(buffer.back() == 999);&#10;    }&#10;&#10;    SECTION(&quot;Mixed operations with complex wraparound&quot;) {&#10;        CircularBuffer&lt;int&gt; buffer(16);&#10;&#10;        // Create complex pattern that causes wraparound&#10;        for (int cycle = 0; cycle &lt; 20; ++cycle) {&#10;            // Add elements&#10;            for (int i = 0; i &lt; 30; ++i) {&#10;                buffer.push_back(cycle * 100 + i);&#10;            }&#10;&#10;            // Remove some from front&#10;            for (int i = 0; i &lt; 15; ++i) {&#10;                buffer.pop_front();&#10;            }&#10;&#10;            // Add some to front&#10;            for (int i = 0; i &lt; 5; ++i) {&#10;                buffer.push_front(-(cycle * 100 + i + 1));&#10;            }&#10;&#10;            // Remove some from back&#10;            for (int i = 0; i &lt; 10; ++i) {&#10;                buffer.pop_back();&#10;            }&#10;        }&#10;&#10;        // Buffer should still be functional&#10;        REQUIRE(buffer.size() &gt; 0);&#10;&#10;        // operator[] should work for all valid indices&#10;        for (size_t i = 0; i &lt; buffer.size(); ++i) {&#10;            REQUIRE_NOTHROW(buffer[i]);&#10;        }&#10;&#10;        // front() and back() should work&#10;        REQUIRE_NOTHROW(buffer.front());&#10;        REQUIRE_NOTHROW(buffer.back());&#10;    }&#10;&#10;    SECTION(&quot;Size is maintained correctly through all operations&quot;) {&#10;        CircularBuffer&lt;int&gt; buffer(4);&#10;        size_t expected_size = 0;&#10;&#10;        // Push back operations&#10;        for (int i = 0; i &lt; 50; ++i) {&#10;            buffer.push_back(i);&#10;            ++expected_size;&#10;            REQUIRE(buffer.size() == expected_size);&#10;        }&#10;&#10;        // Push front operations&#10;        for (int i = 0; i &lt; 30; ++i) {&#10;            buffer.push_front(-i);&#10;            ++expected_size;&#10;            REQUIRE(buffer.size() == expected_size);&#10;        }&#10;&#10;        // Pop back operations&#10;        for (int i = 0; i &lt; 25; ++i) {&#10;            buffer.pop_back();&#10;            --expected_size;&#10;            REQUIRE(buffer.size() == expected_size);&#10;        }&#10;&#10;        // Pop front operations&#10;        for (int i = 0; i &lt; 25; ++i) {&#10;            buffer.pop_front();&#10;            --expected_size;&#10;            REQUIRE(buffer.size() == expected_size);&#10;        }&#10;&#10;        REQUIRE(expected_size == 30);&#10;        REQUIRE(buffer.size() == 30);&#10;    }&#10;&#10;    SECTION(&quot;operator[] correctness after resize operations&quot;) {&#10;        CircularBuffer&lt;int&gt; buffer(4);&#10;&#10;        // Fill with pattern&#10;        for (int i = 0; i &lt; 20; ++i) {&#10;            buffer.push_back(i * 3);  // 0, 3, 6, 9, 12, ...&#10;        }&#10;&#10;        // Verify pattern after upward resize&#10;        for (int i = 0; i &lt; 20; ++i) {&#10;            REQUIRE(buffer[i] == i * 3);&#10;        }&#10;&#10;        // Remove elements from front to trigger potential downward resize&#10;        for (int i = 0; i &lt; 15; ++i) {&#10;            buffer.pop_front();&#10;        }&#10;&#10;        // Verify remaining elements are still correct&#10;        REQUIRE(buffer.size() == 5);&#10;        for (int i = 0; i &lt; 5; ++i) {&#10;            REQUIRE(buffer[i] == (15 + i) * 3);  // Should be 45, 48, 51, 54, 57&#10;        }&#10;    }&#10;}&#10;&#10;TEST_CASE(&quot;CircularBuffer element construction/destruction count&quot;, &quot;[CircularBuffer][Lifetime]&quot;) {&#10;    TestingTracker::constructed = 0;&#10;    TestingTracker::destructed = 0;&#10;&#10;    constexpr int num_elements = 50;&#10;    {&#10;        CircularBuffer&lt;TestingTracker&gt; buffer(8);&#10;        &#10;        // Add elements - this will trigger resizing since we start with capacity 8&#10;        // Resizing will cause move constructions: 8-&gt;16 (8 moves), 16-&gt;32 (16 moves), 32-&gt;64 (32 moves)&#10;        // Total expected constructions: 50 (initial) + 8 + 16 + 32 = 106&#10;        for (int i = 0; i &lt; num_elements; ++i) {&#10;            buffer.emplace_back();&#10;        }&#10;        &#10;        // Account for move constructions during resizing&#10;        // Starting capacity: 8, need to fit 50 elements&#10;        // Resize sequence: 8 -&gt; 16 (8 moves) -&gt; 32 (16 moves) -&gt; 64 (32 moves)&#10;        int expected_constructions = num_elements + 8 + 16 + 32; // 106 total&#10;        REQUIRE(TestingTracker::constructed == expected_constructions);&#10;        REQUIRE(buffer.size() == num_elements);&#10;        &#10;        // Remove some elements&#10;        for (int i = 0; i &lt; 20; ++i) {&#10;            buffer.pop_front();&#10;        }&#10;        // 20 destructions from popping + 8 + 16 + 32 destructions from old buffers during resize = 76&#10;        int expected_destructions = 20 + 8 + 16 + 32; // 76 total&#10;        REQUIRE(TestingTracker::destructed == expected_destructions);&#10;        REQUIRE(buffer.size() == 30);&#10;        &#10;    } // Buffer goes out of scope, remaining 30 elements should be destructed&#10;    // Total destructions: 76 (from above) + 30 (remaining) = 106, matching constructions&#10;    REQUIRE(TestingTracker::destructed == TestingTracker::constructed);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/test_deque.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/test_deque.cpp" />
              <option name="originalContent" value="#include &lt;catch2/catch_test_macros.hpp&gt;&#10;#include &quot;Deque.h&quot;&#10;#include &lt;string&gt;&#10;#include &lt;vector&gt;&#10;&#10;TEST_CASE(&quot;Deque construction&quot;, &quot;[Deque]&quot;) {&#10;    SECTION(&quot;Default construction&quot;) {&#10;        const Deque&lt;int&gt; deque;&#10;        REQUIRE(deque.size() == 0); // NOLINT&#10;    }&#10;}&#10;&#10;TEST_CASE(&quot;Deque push_back operations&quot;, &quot;[Deque]&quot;) {&#10;    Deque&lt;int&gt; deque;&#10;&#10;    SECTION(&quot;Push single element&quot;) {&#10;        deque.push_back(42);&#10;        REQUIRE(deque.size() == 1);&#10;        REQUIRE(deque[0] == 42);&#10;    }&#10;&#10;    SECTION(&quot;Push multiple elements&quot;) {&#10;        for (int i = 0; i &lt; 10; ++i) {&#10;            deque.push_back(i);&#10;        }&#10;        REQUIRE(deque.size() == 10);&#10;        for (int i = 0; i &lt; 10; ++i) {&#10;            REQUIRE(deque[i] == i);&#10;        }&#10;    }&#10;&#10;    SECTION(&quot;Push beyond single FixedArray capacity&quot;) {&#10;        // Push enough elements to trigger multiple FixedArrays&#10;        constexpr int num_elements = 5000; // More than fixed_arr_n_elem&#10;        for (int i = 0; i &lt; num_elements; ++i) {&#10;            deque.push_back(i);&#10;        }&#10;        REQUIRE(deque.size() == num_elements);&#10;        // Verify all elements are accessible and correct&#10;        for (int i = 0; i &lt; num_elements; ++i) {&#10;            REQUIRE(deque[i] == i);&#10;        }&#10;    }&#10;}&#10;&#10;TEST_CASE(&quot;Deque push_front operations&quot;, &quot;[Deque]&quot;) {&#10;    Deque&lt;int&gt; deque;&#10;&#10;    SECTION(&quot;Push single element to front&quot;) {&#10;        deque.push_front(42);&#10;        REQUIRE(deque.size() == 1);&#10;        REQUIRE(deque[0] == 42);&#10;    }&#10;&#10;    SECTION(&quot;Push multiple elements to front&quot;) {&#10;        for (int i = 0; i &lt; 10; ++i) {&#10;            deque.push_front(i);&#10;        }&#10;        REQUIRE(deque.size() == 10);&#10;        // Elements should be in reverse order&#10;        for (int i = 0; i &lt; 10; ++i) {&#10;            REQUIRE(deque[i] == 9 - i);&#10;        }&#10;    }&#10;&#10;    SECTION(&quot;Mix push_front and push_back&quot;) {&#10;        deque.push_back(1);&#10;        deque.push_back(2);&#10;        deque.push_front(0);&#10;        deque.push_front(-1);&#10;&#10;        REQUIRE(deque.size() == 4);&#10;        REQUIRE(deque[0] == -1);&#10;        REQUIRE(deque[1] == 0);&#10;        REQUIRE(deque[2] == 1);&#10;        REQUIRE(deque[3] == 2);&#10;    }&#10;}&#10;&#10;TEST_CASE(&quot;Deque pop operations&quot;, &quot;[Deque]&quot;) {&#10;    Deque&lt;int&gt; deque;&#10;&#10;    SECTION(&quot;Pop from back&quot;) {&#10;        deque.push_back(1);&#10;        deque.push_back(2);&#10;        deque.push_back(3);&#10;&#10;        REQUIRE(deque.pop_back() == 3);&#10;        REQUIRE(deque.size() == 2);&#10;        REQUIRE(deque.pop_back() == 2);&#10;        REQUIRE(deque.size() == 1);&#10;        REQUIRE(deque.pop_back() == 1);&#10;        REQUIRE(deque.size() == 0); // NOLINT&#10;    }&#10;&#10;    SECTION(&quot;Pop from front&quot;) {&#10;        deque.push_back(1);&#10;        deque.push_back(2);&#10;        deque.push_back(3);&#10;&#10;        REQUIRE(deque.pop_front() == 1);&#10;        REQUIRE(deque.size() == 2);&#10;        REQUIRE(deque.pop_front() == 2);&#10;        REQUIRE(deque.size() == 1);&#10;        REQUIRE(deque.pop_front() == 3);&#10;        REQUIRE(deque.size() == 0); // NOLINT&#10;    }&#10;&#10;    SECTION(&quot;Mix pop operations&quot;) {&#10;        for (int i = 0; i &lt; 10; ++i) {&#10;            deque.push_back(i);&#10;        }&#10;&#10;        REQUIRE(deque.pop_front() == 0);&#10;        REQUIRE(deque.pop_back() == 9);&#10;        REQUIRE(deque.pop_front() == 1);&#10;        REQUIRE(deque.pop_back() == 8);&#10;&#10;        REQUIRE(deque.size() == 6);&#10;        REQUIRE(deque[0] == 2);&#10;        REQUIRE(deque[5] == 7);&#10;    }&#10;}&#10;&#10;TEST_CASE(&quot;Deque operator[] access&quot;, &quot;[Deque]&quot;) {&#10;    Deque&lt;int&gt; deque;&#10;&#10;    SECTION(&quot;Random access after mixed operations&quot;) {&#10;        // Fill deque with pattern&#10;        for (int i = 0; i &lt; 100; ++i) {&#10;            if (i % 2 == 0) {&#10;                deque.push_back(i);&#10;            } else {&#10;                deque.push_front(-i);&#10;            }&#10;        }&#10;&#10;        // Verify all elements are accessible&#10;        for (size_t i = 0; i &lt; deque.size(); ++i) { // NOLINT&#10;            // This should not throw and should return a valid value&#10;            REQUIRE_NOTHROW(deque[i]);&#10;        }&#10;    }&#10;&#10;    SECTION(&quot;Access across multiple FixedArrays&quot;) {&#10;        constexpr int num_elements = 10000;&#10;        for (int i = 0; i &lt; num_elements; ++i) {&#10;            deque.push_back(i * 2); // Use a pattern to verify correctness&#10;        }&#10;&#10;        // Test random access across the entire range&#10;        for (int i = 0; i &lt; num_elements; ++i) {&#10;            REQUIRE(deque[i] == i * 2);&#10;        }&#10;&#10;        // Test access at boundaries&#10;        REQUIRE(deque[0] == 0);&#10;        REQUIRE(deque[num_elements - 1] == (num_elements - 1) * 2);&#10;    }&#10;}&#10;&#10;TEST_CASE(&quot;Deque with strings&quot;, &quot;[Deque]&quot;) {&#10;    SECTION(&quot;String operations&quot;) {&#10;        Deque&lt;std::string&gt; deque;&#10;        deque.push_back(std::string(&quot;hello&quot;));&#10;        deque.push_back(&quot;world&quot;);&#10;        deque.push_front(&quot;hi&quot;);&#10;&#10;        REQUIRE(deque.size() == 3);&#10;        REQUIRE(deque[0] == &quot;hi&quot;);&#10;        REQUIRE(deque[1] == &quot;hello&quot;);&#10;        REQUIRE(deque[2] == &quot;world&quot;);&#10;&#10;        REQUIRE(deque.pop_back() == &quot;world&quot;);&#10;        REQUIRE(deque.pop_front() == &quot;hi&quot;);&#10;        REQUIRE(deque[0] == &quot;hello&quot;);&#10;    }&#10;}&#10;&#10;TEST_CASE(&quot;Deque stress test&quot;, &quot;[Deque][Stress]&quot;) {&#10;    Deque&lt;int&gt; deque;&#10;&#10;    SECTION(&quot;Large scale operations&quot;) {&#10;        constexpr int operations = 50000;&#10;&#10;        // Add many elements&#10;        for (int i = 0; i &lt; operations; ++i) {&#10;            deque.push_back(i);&#10;        }&#10;        REQUIRE(deque.size() == operations);&#10;&#10;        // Remove half from front&#10;        for (int i = 0; i &lt; operations / 2; ++i) {&#10;            REQUIRE(deque.pop_front() == i);&#10;        }&#10;        REQUIRE(deque.size() == operations / 2);&#10;&#10;        // Add more to front&#10;        for (int i = 0; i &lt; operations / 4; ++i) {&#10;            deque.push_front(-i - 1);&#10;        }&#10;&#10;        // Verify size and some elements&#10;        REQUIRE(deque.size() == operations / 2 + operations / 4);&#10;        REQUIRE(deque[0] == -operations / 4);&#10;        REQUIRE(deque[operations / 4] == operations / 2);&#10;    }&#10;&#10;    SECTION(&quot;Alternating push/pop pattern&quot;) {&#10;        // This tests the dynamic resizing behavior&#10;        for (int cycle = 0; cycle &lt; 1000; ++cycle) {&#10;            // Push a bunch&#10;            for (int i = 0; i &lt; 100; ++i) {&#10;                deque.push_back(cycle * 100 + i);&#10;            }&#10;&#10;            // Pop some&#10;            for (int i = 0; i &lt; 50; ++i) {&#10;                deque.pop_front();&#10;            }&#10;        }&#10;&#10;        // Should still be functional&#10;        REQUIRE(deque.size() == 50000); // 1000 * (100 - 50)&#10;&#10;        // Test random access still works&#10;        for (size_t i = 0; i &lt; std::min(deque.size(), 100zu); ++i) {&#10;            REQUIRE_NOTHROW(deque[i]);&#10;        }&#10;    }&#10;}&#10;&#10;TEST_CASE(&quot;Deque Constructors&quot;, &quot;[Deque]&quot;) {&#10;    SECTION(&quot;Initializer list construction&quot;) {&#10;        const Deque deque = {1, 2, 3, 4, 5};&#10;        REQUIRE(deque.size() == 5);&#10;        REQUIRE(deque[0] == 1);&#10;        REQUIRE(deque[1] == 2);&#10;        REQUIRE(deque[2] == 3);&#10;        REQUIRE(deque[3] == 4);&#10;        REQUIRE(deque[4] == 5);&#10;        REQUIRE(deque.front() == 1);&#10;        REQUIRE(deque.back() == 5);&#10;    }&#10;&#10;    SECTION(&quot;Initializer list with strings&quot;) {&#10;        Deque&lt;std::string&gt; deque = {&quot;one&quot;, &quot;two&quot;, &quot;three&quot;};&#10;        REQUIRE(deque.size() == 3);&#10;        REQUIRE(deque[0] == &quot;one&quot;);&#10;        REQUIRE(deque[1] == &quot;two&quot;);&#10;        REQUIRE(deque[2] == &quot;three&quot;);&#10;    }&#10;}&#10;&#10;TEST_CASE(&quot;Deque Iterator operations&quot;, &quot;[Deque][Iterator]&quot;) {&#10;    SECTION(&quot;Basic iterator functionality&quot;) {&#10;        Deque deque = {1, 2, 3, 4, 5};&#10;&#10;        // Test begin() and end()&#10;        auto it = deque.begin();&#10;        auto end_it = deque.end();&#10;&#10;        REQUIRE(*it == 1);&#10;&#10;        // Test dereference operator&#10;        REQUIRE(*it == 1);&#10;        *it = 10;&#10;        REQUIRE(*it == 10);&#10;        REQUIRE(deque[0] == 10);&#10;        REQUIRE(*(end_it.prev()) == 5); // Should point to last element&#10;    }&#10;&#10;    SECTION(&quot;Iterator increment operations&quot;) {&#10;        Deque deque = {1, 2, 3, 4, 5};&#10;        auto it = deque.begin();&#10;&#10;        // Test prefix increment&#10;        REQUIRE(*it == 1);&#10;        ++it;&#10;        REQUIRE(*it == 2);&#10;        ++it;&#10;        REQUIRE(*it == 3);&#10;&#10;        // Test postfix increment&#10;        auto old_it = it++;&#10;        REQUIRE(*old_it == 3);&#10;        REQUIRE(*it == 4);&#10;    }&#10;&#10;    SECTION(&quot;Iterator decrement operations&quot;) {&#10;        Deque deque = {1, 2, 3, 4, 5};&#10;        auto it = deque.begin();&#10;&#10;        // Move to middle&#10;        ++it;&#10;        ++it;&#10;        REQUIRE(*it == 3);&#10;&#10;        // Test prefix decrement&#10;        --it;&#10;        REQUIRE(*it == 2);&#10;        --it;&#10;        REQUIRE(*it == 1);&#10;&#10;        // Test postfix decrement&#10;        ++it;&#10;        ++it;&#10;        REQUIRE(*it == 3);&#10;        auto old_it = it--;&#10;        REQUIRE(*old_it == 3);&#10;        REQUIRE(*it == 2);&#10;    }&#10;&#10;    SECTION(&quot;Iterator traversal&quot;) {&#10;        Deque&lt;int&gt; deque;&#10;        for (int i = 0; i &lt; 10; ++i) {&#10;            deque.push_back(i);&#10;        }&#10;&#10;        // Forward traversal&#10;        int expected = 0;&#10;        for (auto it = deque.begin(); it.current_array != nullptr; ++it) {&#10;            REQUIRE(*it == expected);&#10;            ++expected;&#10;        }&#10;        REQUIRE(expected == 10);&#10;&#10;        // Manual traversal using next()&#10;        auto it = deque.begin();&#10;        for (int i = 0; i &lt; 10; ++i) {&#10;            REQUIRE(*it == i);&#10;            it = it.next();&#10;        }&#10;        REQUIRE(it.current_array == nullptr); // Should be at end&#10;    }&#10;&#10;    SECTION(&quot;Iterator with large deque across multiple FixedArrays&quot;) {&#10;        Deque&lt;int&gt; deque;&#10;        constexpr int num_elements = 10000; // Ensure multiple FixedArrays&#10;&#10;        for (int i = 0; i &lt; num_elements; ++i) {&#10;            deque.push_back(i);&#10;        }&#10;&#10;        // Test forward iteration through all elements&#10;        int count = 0;&#10;        for (auto it = deque.begin(); it.current_array != nullptr; ++it) {&#10;            REQUIRE(*it == count);&#10;            ++count;&#10;        }&#10;        REQUIRE(count == num_elements);&#10;&#10;        // Test that we can modify elements through iterator&#10;        auto it = deque.begin();&#10;        for (int i = 0; i &lt; 100; ++i) {&#10;            *it = i * 10;&#10;            ++it;&#10;        }&#10;&#10;        // Verify modifications&#10;        for (int i = 0; i &lt; 100; ++i) {&#10;            REQUIRE(deque[i] == i * 10);&#10;        }&#10;    }&#10;&#10;    SECTION(&quot;Iterator with mixed push operations&quot;) {&#10;        Deque&lt;int&gt; deque;&#10;&#10;        // Create a pattern: push_front some, push_back some&#10;        for (int i = 0; i &lt; 5; ++i) {&#10;            deque.push_front(-i - 1); // -1, -2, -3, -4, -5&#10;            deque.push_back(i + 1); //  1,  2,  3,  4,  5&#10;        }&#10;&#10;        // Expected order: [-5, -4, -3, -2, -1, 1, 2, 3, 4, 5]&#10;        std::vector expected = {-5, -4, -3, -2, -1, 1, 2, 3, 4, 5};&#10;&#10;        int index = 0;&#10;        for (auto it = deque.begin(); it.current_array != nullptr; ++it) {&#10;            REQUIRE(*it == expected[index]);&#10;            ++index;&#10;        }&#10;        REQUIRE(index == expected.size());&#10;    }&#10;&#10;    SECTION(&quot;Range-based for loop&quot;) {&#10;        Deque&lt;std::string&gt; deque = {&quot;hello&quot;, &quot;world&quot;, &quot;test&quot;};&#10;&#10;        std::vector&lt;std::string&gt; collected;&#10;        for (const auto &amp;item: deque) {&#10;            collected.push_back(item);&#10;        }&#10;&#10;        REQUIRE(collected.size() == 3);&#10;        REQUIRE(collected[0] == &quot;hello&quot;);&#10;        REQUIRE(collected[1] == &quot;world&quot;);&#10;        REQUIRE(collected[2] == &quot;test&quot;);&#10;    }&#10;&#10;    SECTION(&quot;Empty deque iterator&quot;) {&#10;        Deque&lt;int&gt; deque;&#10;&#10;        auto begin_it = deque.begin();&#10;        auto end_it = deque.end();&#10;&#10;        // For empty deque, begin should point to end immediately&#10;        REQUIRE(begin_it.current_array == nullptr); // Points to the initial FixedArray&#10;        REQUIRE(end_it.current_array == nullptr);&#10;        ++begin_it;&#10;        REQUIRE(begin_it.current_array == nullptr);&#10;    }&#10;&#10;    SECTION(&quot;Iterator prev() method&quot;) {&#10;        Deque deque = {1, 2, 3, 4, 5};&#10;&#10;        // Start from end and work backwards using prev()&#10;        auto it = deque.end().prev();&#10;        REQUIRE(*it == 5);&#10;&#10;        it = it.prev();&#10;        REQUIRE(*it == 4);&#10;&#10;        it = it.prev();&#10;        REQUIRE(*it == 3);&#10;&#10;        it = it.prev();&#10;        REQUIRE(*it == 2);&#10;&#10;        it = it.prev();&#10;        REQUIRE(*it == 1);&#10;    }&#10;&#10;    SECTION(&quot;Iterator boundary conditions&quot;) {&#10;        Deque&lt;int&gt; deque;&#10;&#10;        // Test with exactly one element&#10;        deque.push_back(42);&#10;        auto it = deque.begin();&#10;        REQUIRE(*it == 42);&#10;&#10;        ++it;&#10;        REQUIRE(it.current_array == nullptr); // Should be at end&#10;&#10;        // Test prev from end&#10;        it = deque.end().prev();&#10;        REQUIRE(*it == 42);&#10;    }&#10;}&#10;&#10;class Tracker {&#10;public:&#10;    static int constructed;&#10;    static int destructed;&#10;&#10;    Tracker() {&#10;        constructed++;&#10;    }&#10;&#10;    Tracker(const Tracker &amp;) {&#10;        constructed++;&#10;    }&#10;&#10;    ~Tracker() {&#10;        destructed++;&#10;    }&#10;};&#10;int Tracker::constructed = 0;&#10;int Tracker::destructed = 0;&#10;&#10;&#10;TEST_CASE(&quot;Deque element construction/destruction count&quot;, &quot;[Deque][Lifetime]&quot;) {&#10;    Tracker::constructed = 0;&#10;    Tracker::destructed = 0;&#10;&#10;    constexpr int num_elements = 100; {&#10;        Deque&lt;Tracker&gt; deque;&#10;        for (int i = 0; i &lt; num_elements; ++i) {&#10;            deque.emplace_back();&#10;        }&#10;        REQUIRE(Tracker::constructed == num_elements);&#10;        REQUIRE(deque.size() == num_elements);&#10;    } // Deque goes out of scope, all elements should be destructed&#10;    REQUIRE(Tracker::destructed == num_elements);&#10;}&#10;" />
              <option name="updatedContent" value="#include &lt;catch2/catch_test_macros.hpp&gt;&#10;#include &quot;Deque.h&quot;&#10;#include &lt;string&gt;&#10;#include &lt;vector&gt;&#10;&#10;TEST_CASE(&quot;Deque construction&quot;, &quot;[Deque]&quot;) {&#10;    SECTION(&quot;Default construction&quot;) {&#10;        const Deque&lt;int&gt; deque;&#10;        REQUIRE(deque.size() == 0); // NOLINT&#10;    }&#10;}&#10;&#10;TEST_CASE(&quot;Deque push_back operations&quot;, &quot;[Deque]&quot;) {&#10;    Deque&lt;int&gt; deque;&#10;&#10;    SECTION(&quot;Push single element&quot;) {&#10;        deque.push_back(42);&#10;        REQUIRE(deque.size() == 1);&#10;        REQUIRE(deque[0] == 42);&#10;    }&#10;&#10;    SECTION(&quot;Push multiple elements&quot;) {&#10;        for (int i = 0; i &lt; 10; ++i) {&#10;            deque.push_back(i);&#10;        }&#10;        REQUIRE(deque.size() == 10);&#10;        for (int i = 0; i &lt; 10; ++i) {&#10;            REQUIRE(deque[i] == i);&#10;        }&#10;    }&#10;&#10;    SECTION(&quot;Push beyond single FixedArray capacity&quot;) {&#10;        // Push enough elements to trigger multiple FixedArrays&#10;        constexpr int num_elements = 5000; // More than fixed_arr_n_elem&#10;        for (int i = 0; i &lt; num_elements; ++i) {&#10;            deque.push_back(i);&#10;        }&#10;        REQUIRE(deque.size() == num_elements);&#10;        // Verify all elements are accessible and correct&#10;        for (int i = 0; i &lt; num_elements; ++i) {&#10;            REQUIRE(deque[i] == i);&#10;        }&#10;    }&#10;}&#10;&#10;TEST_CASE(&quot;Deque push_front operations&quot;, &quot;[Deque]&quot;) {&#10;    Deque&lt;int&gt; deque;&#10;&#10;    SECTION(&quot;Push single element to front&quot;) {&#10;        deque.push_front(42);&#10;        REQUIRE(deque.size() == 1);&#10;        REQUIRE(deque[0] == 42);&#10;    }&#10;&#10;    SECTION(&quot;Push multiple elements to front&quot;) {&#10;        for (int i = 0; i &lt; 10; ++i) {&#10;            deque.push_front(i);&#10;        }&#10;        REQUIRE(deque.size() == 10);&#10;        // Elements should be in reverse order&#10;        for (int i = 0; i &lt; 10; ++i) {&#10;            REQUIRE(deque[i] == 9 - i);&#10;        }&#10;    }&#10;&#10;    SECTION(&quot;Mix push_front and push_back&quot;) {&#10;        deque.push_back(1);&#10;        deque.push_back(2);&#10;        deque.push_front(0);&#10;        deque.push_front(-1);&#10;&#10;        REQUIRE(deque.size() == 4);&#10;        REQUIRE(deque[0] == -1);&#10;        REQUIRE(deque[1] == 0);&#10;        REQUIRE(deque[2] == 1);&#10;        REQUIRE(deque[3] == 2);&#10;    }&#10;}&#10;&#10;TEST_CASE(&quot;Deque pop operations&quot;, &quot;[Deque]&quot;) {&#10;    Deque&lt;int&gt; deque;&#10;&#10;    SECTION(&quot;Pop from back&quot;) {&#10;        deque.push_back(1);&#10;        deque.push_back(2);&#10;        deque.push_back(3);&#10;&#10;        REQUIRE(deque.pop_back() == 3);&#10;        REQUIRE(deque.size() == 2);&#10;        REQUIRE(deque.pop_back() == 2);&#10;        REQUIRE(deque.size() == 1);&#10;        REQUIRE(deque.pop_back() == 1);&#10;        REQUIRE(deque.size() == 0); // NOLINT&#10;    }&#10;&#10;    SECTION(&quot;Pop from front&quot;) {&#10;        deque.push_back(1);&#10;        deque.push_back(2);&#10;        deque.push_back(3);&#10;&#10;        REQUIRE(deque.pop_front() == 1);&#10;        REQUIRE(deque.size() == 2);&#10;        REQUIRE(deque.pop_front() == 2);&#10;        REQUIRE(deque.size() == 1);&#10;        REQUIRE(deque.pop_front() == 3);&#10;        REQUIRE(deque.size() == 0); // NOLINT&#10;    }&#10;&#10;    SECTION(&quot;Mix pop operations&quot;) {&#10;        for (int i = 0; i &lt; 10; ++i) {&#10;            deque.push_back(i);&#10;        }&#10;&#10;        REQUIRE(deque.pop_front() == 0);&#10;        REQUIRE(deque.pop_back() == 9);&#10;        REQUIRE(deque.pop_front() == 1);&#10;        REQUIRE(deque.pop_back() == 8);&#10;&#10;        REQUIRE(deque.size() == 6);&#10;        REQUIRE(deque[0] == 2);&#10;        REQUIRE(deque[5] == 7);&#10;    }&#10;}&#10;&#10;TEST_CASE(&quot;Deque operator[] access&quot;, &quot;[Deque]&quot;) {&#10;    Deque&lt;int&gt; deque;&#10;&#10;    SECTION(&quot;Random access after mixed operations&quot;) {&#10;        // Fill deque with pattern&#10;        for (int i = 0; i &lt; 100; ++i) {&#10;            if (i % 2 == 0) {&#10;                deque.push_back(i);&#10;            } else {&#10;                deque.push_front(-i);&#10;            }&#10;        }&#10;&#10;        // Verify all elements are accessible&#10;        for (size_t i = 0; i &lt; deque.size(); ++i) { // NOLINT&#10;            // This should not throw and should return a valid value&#10;            REQUIRE_NOTHROW(deque[i]);&#10;        }&#10;    }&#10;&#10;    SECTION(&quot;Access across multiple FixedArrays&quot;) {&#10;        constexpr int num_elements = 10000;&#10;        for (int i = 0; i &lt; num_elements; ++i) {&#10;            deque.push_back(i * 2); // Use a pattern to verify correctness&#10;        }&#10;&#10;        // Test random access across the entire range&#10;        for (int i = 0; i &lt; num_elements; ++i) {&#10;            REQUIRE(deque[i] == i * 2);&#10;        }&#10;&#10;        // Test access at boundaries&#10;        REQUIRE(deque[0] == 0);&#10;        REQUIRE(deque[num_elements - 1] == (num_elements - 1) * 2);&#10;    }&#10;}&#10;&#10;TEST_CASE(&quot;Deque with strings&quot;, &quot;[Deque]&quot;) {&#10;    SECTION(&quot;String operations&quot;) {&#10;        Deque&lt;std::string&gt; deque;&#10;        deque.push_back(std::string(&quot;hello&quot;));&#10;        deque.push_back(&quot;world&quot;);&#10;        deque.push_front(&quot;hi&quot;);&#10;&#10;        REQUIRE(deque.size() == 3);&#10;        REQUIRE(deque[0] == &quot;hi&quot;);&#10;        REQUIRE(deque[1] == &quot;hello&quot;);&#10;        REQUIRE(deque[2] == &quot;world&quot;);&#10;&#10;        REQUIRE(deque.pop_back() == &quot;world&quot;);&#10;        REQUIRE(deque.pop_front() == &quot;hi&quot;);&#10;        REQUIRE(deque[0] == &quot;hello&quot;);&#10;    }&#10;}&#10;&#10;TEST_CASE(&quot;Deque stress test&quot;, &quot;[Deque][Stress]&quot;) {&#10;    Deque&lt;int&gt; deque;&#10;&#10;    SECTION(&quot;Large scale operations&quot;) {&#10;        constexpr int operations = 50000;&#10;&#10;        // Add many elements&#10;        for (int i = 0; i &lt; operations; ++i) {&#10;            deque.push_back(i);&#10;        }&#10;        REQUIRE(deque.size() == operations);&#10;&#10;        // Remove half from front&#10;        for (int i = 0; i &lt; operations / 2; ++i) {&#10;            REQUIRE(deque.pop_front() == i);&#10;        }&#10;        REQUIRE(deque.size() == operations / 2);&#10;&#10;        // Add more to front&#10;        for (int i = 0; i &lt; operations / 4; ++i) {&#10;            deque.push_front(-i - 1);&#10;        }&#10;&#10;        // Verify size and some elements&#10;        REQUIRE(deque.size() == operations / 2 + operations / 4);&#10;        REQUIRE(deque[0] == -operations / 4);&#10;        REQUIRE(deque[operations / 4] == operations / 2);&#10;    }&#10;&#10;    SECTION(&quot;Alternating push/pop pattern&quot;) {&#10;        // This tests the dynamic resizing behavior&#10;        for (int cycle = 0; cycle &lt; 1000; ++cycle) {&#10;            // Push a bunch&#10;            for (int i = 0; i &lt; 100; ++i) {&#10;                deque.push_back(cycle * 100 + i);&#10;            }&#10;&#10;            // Pop some&#10;            for (int i = 0; i &lt; 50; ++i) {&#10;                deque.pop_front();&#10;            }&#10;        }&#10;&#10;        // Should still be functional&#10;        REQUIRE(deque.size() == 50000); // 1000 * (100 - 50)&#10;&#10;        // Test random access still works&#10;        for (size_t i = 0; i &lt; std::min(deque.size(), 100zu); ++i) {&#10;            REQUIRE_NOTHROW(deque[i]);&#10;        }&#10;    }&#10;}&#10;&#10;TEST_CASE(&quot;Deque Constructors&quot;, &quot;[Deque]&quot;) {&#10;    SECTION(&quot;Initializer list construction&quot;) {&#10;        const Deque deque = {1, 2, 3, 4, 5};&#10;        REQUIRE(deque.size() == 5);&#10;        REQUIRE(deque[0] == 1);&#10;        REQUIRE(deque[1] == 2);&#10;        REQUIRE(deque[2] == 3);&#10;        REQUIRE(deque[3] == 4);&#10;        REQUIRE(deque[4] == 5);&#10;        REQUIRE(deque.front() == 1);&#10;        REQUIRE(deque.back() == 5);&#10;    }&#10;&#10;    SECTION(&quot;Initializer list with strings&quot;) {&#10;        Deque&lt;std::string&gt; deque = {&quot;one&quot;, &quot;two&quot;, &quot;three&quot;};&#10;        REQUIRE(deque.size() == 3);&#10;        REQUIRE(deque[0] == &quot;one&quot;);&#10;        REQUIRE(deque[1] == &quot;two&quot;);&#10;        REQUIRE(deque[2] == &quot;three&quot;);&#10;    }&#10;}&#10;&#10;TEST_CASE(&quot;Deque Iterator operations&quot;, &quot;[Deque][Iterator]&quot;) {&#10;    SECTION(&quot;Basic iterator functionality&quot;) {&#10;        Deque deque = {1, 2, 3, 4, 5};&#10;&#10;        // Test begin() and end()&#10;        auto it = deque.begin();&#10;        auto end_it = deque.end();&#10;&#10;        REQUIRE(*it == 1);&#10;&#10;        // Test dereference operator&#10;        REQUIRE(*it == 1);&#10;        *it = 10;&#10;        REQUIRE(*it == 10);&#10;        REQUIRE(deque[0] == 10);&#10;        REQUIRE(*(end_it.prev()) == 5); // Should point to last element&#10;    }&#10;&#10;    SECTION(&quot;Iterator increment operations&quot;) {&#10;        Deque deque = {1, 2, 3, 4, 5};&#10;        auto it = deque.begin();&#10;&#10;        // Test prefix increment&#10;        REQUIRE(*it == 1);&#10;        ++it;&#10;        REQUIRE(*it == 2);&#10;        ++it;&#10;        REQUIRE(*it == 3);&#10;&#10;        // Test postfix increment&#10;        auto old_it = it++;&#10;        REQUIRE(*old_it == 3);&#10;        REQUIRE(*it == 4);&#10;    }&#10;&#10;    SECTION(&quot;Iterator decrement operations&quot;) {&#10;        Deque deque = {1, 2, 3, 4, 5};&#10;        auto it = deque.begin();&#10;&#10;        // Move to middle&#10;        ++it;&#10;        ++it;&#10;        REQUIRE(*it == 3);&#10;&#10;        // Test prefix decrement&#10;        --it;&#10;        REQUIRE(*it == 2);&#10;        --it;&#10;        REQUIRE(*it == 1);&#10;&#10;        // Test postfix decrement&#10;        ++it;&#10;        ++it;&#10;        REQUIRE(*it == 3);&#10;        auto old_it = it--;&#10;        REQUIRE(*old_it == 3);&#10;        REQUIRE(*it == 2);&#10;    }&#10;&#10;    SECTION(&quot;Iterator traversal&quot;) {&#10;        Deque&lt;int&gt; deque;&#10;        for (int i = 0; i &lt; 10; ++i) {&#10;            deque.push_back(i);&#10;        }&#10;&#10;        // Forward traversal&#10;        int expected = 0;&#10;        for (auto it = deque.begin(); it.current_array != nullptr; ++it) {&#10;            REQUIRE(*it == expected);&#10;            ++expected;&#10;        }&#10;        REQUIRE(expected == 10);&#10;&#10;        // Manual traversal using next()&#10;        auto it = deque.begin();&#10;        for (int i = 0; i &lt; 10; ++i) {&#10;            REQUIRE(*it == i);&#10;            it = it.next();&#10;        }&#10;        REQUIRE(it.current_array == nullptr); // Should be at end&#10;    }&#10;&#10;    SECTION(&quot;Iterator with large deque across multiple FixedArrays&quot;) {&#10;        Deque&lt;int&gt; deque;&#10;        constexpr int num_elements = 10000; // Ensure multiple FixedArrays&#10;&#10;        for (int i = 0; i &lt; num_elements; ++i) {&#10;            deque.push_back(i);&#10;        }&#10;&#10;        // Test forward iteration through all elements&#10;        int count = 0;&#10;        for (auto it = deque.begin(); it.current_array != nullptr; ++it) {&#10;            REQUIRE(*it == count);&#10;            ++count;&#10;        }&#10;        REQUIRE(count == num_elements);&#10;&#10;        // Test that we can modify elements through iterator&#10;        auto it = deque.begin();&#10;        for (int i = 0; i &lt; 100; ++i) {&#10;            *it = i * 10;&#10;            ++it;&#10;        }&#10;&#10;        // Verify modifications&#10;        for (int i = 0; i &lt; 100; ++i) {&#10;            REQUIRE(deque[i] == i * 10);&#10;        }&#10;    }&#10;&#10;    SECTION(&quot;Iterator with mixed push operations&quot;) {&#10;        Deque&lt;int&gt; deque;&#10;&#10;        // Create a pattern: push_front some, push_back some&#10;        for (int i = 0; i &lt; 5; ++i) {&#10;            deque.push_front(-i - 1); // -1, -2, -3, -4, -5&#10;            deque.push_back(i + 1); //  1,  2,  3,  4,  5&#10;        }&#10;&#10;        // Expected order: [-5, -4, -3, -2, -1, 1, 2, 3, 4, 5]&#10;        std::vector expected = {-5, -4, -3, -2, -1, 1, 2, 3, 4, 5};&#10;&#10;        int index = 0;&#10;        for (auto it = deque.begin(); it.current_array != nullptr; ++it) {&#10;            REQUIRE(*it == expected[index]);&#10;            ++index;&#10;        }&#10;        REQUIRE(index == expected.size());&#10;    }&#10;&#10;    SECTION(&quot;Range-based for loop&quot;) {&#10;        Deque&lt;std::string&gt; deque = {&quot;hello&quot;, &quot;world&quot;, &quot;test&quot;};&#10;&#10;        std::vector&lt;std::string&gt; collected;&#10;        for (const auto &amp;item: deque) {&#10;            collected.push_back(item);&#10;        }&#10;&#10;        REQUIRE(collected.size() == 3);&#10;        REQUIRE(collected[0] == &quot;hello&quot;);&#10;        REQUIRE(collected[1] == &quot;world&quot;);&#10;        REQUIRE(collected[2] == &quot;test&quot;);&#10;    }&#10;&#10;    SECTION(&quot;Empty deque iterator&quot;) {&#10;        Deque&lt;int&gt; deque;&#10;&#10;        auto begin_it = deque.begin();&#10;        auto end_it = deque.end();&#10;&#10;        // For empty deque, begin should point to end immediately&#10;        REQUIRE(begin_it.current_array == nullptr); // Points to the initial FixedArray&#10;        REQUIRE(end_it.current_array == nullptr);&#10;        ++begin_it;&#10;        REQUIRE(begin_it.current_array == nullptr);&#10;    }&#10;&#10;    SECTION(&quot;Iterator prev() method&quot;) {&#10;        Deque deque = {1, 2, 3, 4, 5};&#10;&#10;        // Start from end and work backwards using prev()&#10;        auto it = deque.end().prev();&#10;        REQUIRE(*it == 5);&#10;&#10;        it = it.prev();&#10;        REQUIRE(*it == 4);&#10;&#10;        it = it.prev();&#10;        REQUIRE(*it == 3);&#10;&#10;        it = it.prev();&#10;        REQUIRE(*it == 2);&#10;&#10;        it = it.prev();&#10;        REQUIRE(*it == 1);&#10;    }&#10;&#10;    SECTION(&quot;Iterator boundary conditions&quot;) {&#10;        Deque&lt;int&gt; deque;&#10;&#10;        // Test with exactly one element&#10;        deque.push_back(42);&#10;        auto it = deque.begin();&#10;        REQUIRE(*it == 42);&#10;&#10;        ++it;&#10;        REQUIRE(it.current_array == nullptr); // Should be at end&#10;&#10;        // Test prev from end&#10;        it = deque.end().prev();&#10;        REQUIRE(*it == 42);&#10;    }&#10;}&#10;&#10;class Tracker {&#10;public:&#10;    static int constructed;&#10;    static int destructed;&#10;&#10;    Tracker() {&#10;        constructed++;&#10;    }&#10;&#10;    Tracker(const Tracker &amp;) {&#10;        constructed++;&#10;    }&#10;&#10;    ~Tracker() {&#10;        destructed++;&#10;    }&#10;};&#10;&#10;int Tracker::constructed = 0;&#10;int Tracker::destructed = 0;&#10;&#10;TEST_CASE(&quot;Deque element construction/destruction count&quot;, &quot;[Deque][Lifetime]&quot;) {&#10;    Tracker::constructed = 0;&#10;    Tracker::destructed = 0;&#10;&#10;    constexpr int num_elements = 100; {&#10;        Deque&lt;Tracker&gt; deque;&#10;        for (int i = 0; i &lt; num_elements; ++i) {&#10;            deque.emplace_back();&#10;        }&#10;        REQUIRE(Tracker::constructed == num_elements);&#10;        REQUIRE(deque.size() == num_elements);&#10;    } // Deque goes out of scope, all elements should be destructed&#10;    REQUIRE(Tracker::destructed == num_elements);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>