<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/CMakeLists.txt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/CMakeLists.txt" />
              <option name="originalContent" value="cmake_minimum_required(VERSION 3.31.6)&#10;project(DataStructures)&#10;&#10;set(CMAKE_CXX_STANDARD 26)&#10;set(CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -fsanitize=address,undefined -fno-omit-frame-pointer&quot;)&#10;set(CMAKE_LINKER_FLAGS &quot;${CMAKE_LINKER_FLAGS} -fsanitize=address,undefined&quot;)&#10;&#10;find_package(Catch2)&#10;&#10;add_executable(DataStructures main.cpp&#10;        CachingAllocator.h)&#10;&#10;add_executable(tests&#10;        test_circular_buffer.cpp&#10;        test_deque.cpp&#10;        TestingTracker.h)&#10;target_link_libraries(tests PRIVATE Catch2::Catch2WithMain)&#10;enable_testing()&#10;add_test(NAME CircularBufferTests COMMAND tests)" />
              <option name="updatedContent" value="cmake_minimum_required(VERSION 3.31.6)&#10;project(DataStructures)&#10;&#10;set(CMAKE_CXX_STANDARD 26)&#10;set(CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -fsanitize=address,undefined -fno-omit-frame-pointer&quot;)&#10;set(CMAKE_LINKER_FLAGS &quot;${CMAKE_LINKER_FLAGS} -fsanitize=address,undefined&quot;)&#10;&#10;find_package(Catch2)&#10;&#10;add_executable(DataStructures main.cpp&#10;        CachingAllocator.h)&#10;&#10;add_executable(tests&#10;        test_circular_buffer.cpp&#10;        test_deque.cpp&#10;        TestingTracker.h&#10;        TestingTracker.cpp)&#10;target_link_libraries(tests PRIVATE Catch2::Catch2WithMain)&#10;enable_testing()&#10;add_test(NAME CircularBufferTests COMMAND tests)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/CircularBuffer.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/CircularBuffer.h" />
              <option name="originalContent" value="#pragma once&#10;&#10;#include &lt;algorithm&gt;&#10;#include &lt;cassert&gt;&#10;#include &lt;memory&gt;&#10;&#10;template&lt;typename T&gt;&#10;class CircularBuffer {&#10;    static constexpr size_t min_cap{8}; // minimum capacity, ovoid unnecessary resizing&#10;    struct AlignedDeleter {&#10;        void operator()(std::byte *ptr) const {&#10;            operator delete[](ptr, std::align_val_t{alignof(T)});&#10;        }&#10;    };&#10;&#10;    std::unique_ptr&lt;std::byte[], AlignedDeleter&gt; data_storage;&#10;&#10;    T *data{nullptr};&#10;    size_t begin{0};&#10;    size_t end{0};&#10;    size_t size_{0};&#10;    size_t capacity_{0};&#10;&#10;    void resize(const size_t new_capacity) {&#10;        std::unique_ptr&lt;std::byte[], AlignedDeleter&gt; new_storage{&#10;            new(std::align_val_t{alignof(T)}) std::byte[new_capacity * sizeof(T)]&#10;        };&#10;        assert(new_storage &amp;&amp; &quot;Memory allocation failed&quot;);&#10;        T *new_data = reinterpret_cast&lt;T *&gt;(new_storage.get());&#10;&#10;        for (size_t i = 0; i &lt; size_; ++i) {&#10;            new(&amp;new_data[i]) T(std::move(data[(begin + i) % capacity_]));&#10;        }&#10;&#10;        data_storage = std::move(new_storage);&#10;        data = new_data;&#10;        capacity_ = new_capacity;&#10;        begin = 0;&#10;        end = size_;&#10;    }&#10;&#10;    void resize_up() {&#10;        const size_t new_capacity = std::max(capacity_ * 2, min_cap);&#10;        resize(new_capacity);&#10;    }&#10;&#10;    void resize_down() {&#10;        const size_t new_capacity = std::max(capacity_ / 2, min_cap);&#10;        resize(new_capacity);&#10;    }&#10;&#10;    template&lt;typename... Args&gt;&#10;    void emplace_back_impl(Args &amp;&amp;... args) {&#10;        if (size_ &lt; capacity_) [[likely]] {&#10;            new(&amp;data[end]) T(std::forward&lt;Args&gt;(args)...);&#10;            end = (end + 1) % capacity_;&#10;        } else {&#10;            // Buffer is full, need to resize&#10;            resize_up();&#10;            new(&amp;data[end]) T(std::forward&lt;Args&gt;(args)...);&#10;            end = end + 1;&#10;        }&#10;        ++size_;&#10;    }&#10;&#10;    template&lt;typename... Args&gt;&#10;    void emplace_front_impl(Args &amp;&amp;... args) {&#10;        if (size_ &lt; capacity_) [[likely]] {&#10;            begin = begin == 0 ? capacity_ - 1 : begin - 1;&#10;            new(&amp;data[begin]) T(std::forward&lt;Args&gt;(args)...);&#10;        } else {&#10;            // Buffer is full, need to resize&#10;            resize_up();&#10;            begin = capacity_ - 1;&#10;            new(&amp;data[begin]) T(std::forward&lt;Args&gt;(args)...);&#10;        }&#10;        ++size_;&#10;    }&#10;&#10;public:&#10;    explicit CircularBuffer(const size_t _cap = min_cap) : capacity_(_cap) {&#10;        assert(_cap &gt;= 1 &amp;&amp; &quot;Capacity must be at least 1&quot;);&#10;        data_storage = std::unique_ptr&lt;std::byte[], AlignedDeleter&gt;(&#10;            new(std::align_val_t{alignof(T)}) std::byte[_cap * sizeof(T)]&#10;        );&#10;        assert(data_storage &amp;&amp; &quot;Memory allocation failed&quot;);&#10;        data = reinterpret_cast&lt;T *&gt;(data_storage.get());&#10;        begin = 0;&#10;        end = 0;&#10;        size_ = 0;&#10;    }&#10;&#10;    // Rule of 5 Methods&#10;    ~CircularBuffer() {&#10;        for (size_t i = 0; i &lt; size_; ++i) {&#10;            data[(begin + i) % capacity_].~T(); // Explicitly call destructor&#10;        }&#10;    }&#10;&#10;    CircularBuffer &amp;operator=(const CircularBuffer &amp;) = delete;&#10;&#10;    CircularBuffer(const CircularBuffer &amp;) = delete;&#10;&#10;    CircularBuffer &amp;operator=(CircularBuffer &amp;&amp;other) noexcept {&#10;        if (this != &amp;other) {&#10;            for (size_t i = 0; i &lt; size_; ++i) {&#10;                data[(begin + i) % capacity_].~T(); // Explicitly call destructor&#10;            }&#10;            data_storage = std::move(other.data_storage);&#10;            data = other.data;&#10;            begin = other.begin;&#10;            end = other.end;&#10;            size_ = other.size_;&#10;            capacity_ = other.capacity_;&#10;            other.data = nullptr; // Prevent double deletion&#10;        }&#10;        return *this;&#10;    }&#10;&#10;    CircularBuffer(CircularBuffer &amp;&amp;other) noexcept&#10;        : data_storage(std::move(other.data_storage)), data(other.data),&#10;          begin(other.begin), end(other.end), size_(other.size_),&#10;          capacity_(other.capacity_) {&#10;        other.data = nullptr; // Prevent double deletion&#10;    }&#10;&#10;    void push_back(const T &amp;value) requires std::copy_constructible&lt;T&gt; {&#10;        emplace_back_impl(value);&#10;    }&#10;&#10;    void push_back(T &amp;&amp;value) requires std::move_constructible&lt;T&gt; {&#10;        emplace_back_impl(std::move(value));&#10;    }&#10;&#10;    template&lt;typename... Args&gt;&#10;    void emplace_back(Args &amp;&amp;... args) requires std::constructible_from&lt;T,&#10;        Args...&gt; {&#10;        emplace_back_impl(std::forward&lt;Args&gt;(args)...);&#10;    }&#10;&#10;    void push_front(const T &amp;value) requires std::copy_constructible&lt;T&gt; {&#10;        emplace_front_impl(value);&#10;    }&#10;&#10;    void push_front(T &amp;&amp;value) requires std::move_constructible&lt;T&gt; {&#10;        emplace_front_impl(std::move(value));&#10;    }&#10;&#10;    template&lt;typename... Args&gt;&#10;    void emplace_front(Args &amp;&amp;... args) requires std::constructible_from&lt;T,&#10;        Args...&gt; {&#10;        emplace_front_impl(std::forward&lt;Args&gt;(args)...);&#10;    }&#10;&#10;    T pop_back() {&#10;        assert(size_ &gt; 0 &amp;&amp; &quot;Cannot pop from an empty buffer&quot;);&#10;        end = end == 0 ? capacity_ - 1 : end - 1;&#10;        T value = std::move(data[end]);&#10;        data[end].~T();&#10;        --size_;&#10;        if (size_ &lt; capacity_ / 4 &amp;&amp; capacity_ &gt; min_cap) {&#10;            resize_down();&#10;        }&#10;        return value;&#10;    }&#10;&#10;    T pop_front() {&#10;        assert(size_ &gt; 0 &amp;&amp; &quot;Cannot pop from an empty buffer&quot;);&#10;        T value = std::move(data[begin]);&#10;        data[begin].~T(); // Explicitly call destructor&#10;        begin = (begin + 1) % capacity_;&#10;        --size_;&#10;        if (size_ &lt; capacity_ / 4 &amp;&amp; capacity_ &gt; min_cap) {&#10;            resize_down();&#10;        }&#10;        return value;&#10;    }&#10;&#10;    template&lt;typename Self&gt;&#10;    auto &amp;&amp;operator[](this Self &amp;&amp;self, const size_t index) {&#10;        assert(index &lt; self.size_ &amp;&amp; &quot;Index out of bounds&quot;);&#10;        return self.data[(self.begin + index) % self.capacity_];&#10;    }&#10;&#10;    template&lt;typename Self&gt;&#10;    auto &amp;&amp;back(this Self &amp;&amp;self) {&#10;        assert(self.size_ &gt; 0 &amp;&amp; &quot;Buffer is empty&quot;);&#10;        return self.data[(self.end == 0 ? self.capacity_ - 1 : self.end - 1)];&#10;    }&#10;&#10;    template&lt;typename Self&gt;&#10;    auto &amp;&amp;front(this Self &amp;&amp;self) {&#10;        assert(self.size_ &gt; 0 &amp;&amp; &quot;Buffer is empty&quot;);&#10;        return self.data[self.begin];&#10;    }&#10;&#10;    [[nodiscard]] size_t size() const {&#10;        return size_;&#10;    }&#10;&#10;    [[nodiscard]] size_t capacity() const {&#10;        return capacity_;&#10;    }&#10;&#10;    [[nodiscard]] bool empty() const {&#10;        return size_ == 0;&#10;    }&#10;};&#10;&#10;" />
              <option name="updatedContent" value="#pragma once&#10;&#10;#include &lt;algorithm&gt;&#10;#include &lt;cassert&gt;&#10;#include &lt;memory&gt;&#10;&#10;template&lt;typename T&gt;&#10;class CircularBuffer {&#10;    static constexpr size_t min_cap{8}; // minimum capacity, ovoid unnecessary resizing&#10;    struct AlignedDeleter {&#10;        void operator()(std::byte *ptr) const {&#10;            operator delete[](ptr, std::align_val_t{alignof(T)});&#10;        }&#10;    };&#10;&#10;    std::unique_ptr&lt;std::byte[], AlignedDeleter&gt; data_storage;&#10;&#10;    T *data{nullptr};&#10;    size_t begin_pos{0};&#10;    size_t end_pos{0};&#10;    size_t size_{0};&#10;    size_t capacity_{0};&#10;&#10;    void resize(const size_t new_capacity) {&#10;        std::unique_ptr&lt;std::byte[], AlignedDeleter&gt; new_storage{&#10;            new(std::align_val_t{alignof(T)}) std::byte[new_capacity * sizeof(T)]&#10;        };&#10;        assert(new_storage &amp;&amp; &quot;Memory allocation failed&quot;);&#10;        T *new_data = reinterpret_cast&lt;T *&gt;(new_storage.get());&#10;&#10;        for (size_t i = 0; i &lt; size_; ++i) {&#10;            new(&amp;new_data[i]) T(std::move(data[(begin_pos + i) % capacity_]));&#10;        }&#10;&#10;        data_storage = std::move(new_storage);&#10;        data = new_data;&#10;        capacity_ = new_capacity;&#10;        begin_pos = 0;&#10;        end_pos = size_;&#10;    }&#10;&#10;    void resize_up() {&#10;        const size_t new_capacity = std::max(capacity_ * 2, min_cap);&#10;        resize(new_capacity);&#10;    }&#10;&#10;    void resize_down() {&#10;        const size_t new_capacity = std::max(capacity_ / 2, min_cap);&#10;        resize(new_capacity);&#10;    }&#10;&#10;    template&lt;typename... Args&gt;&#10;    void emplace_back_impl(Args &amp;&amp;... args) {&#10;        if (size_ &lt; capacity_) [[likely]] {&#10;            new(&amp;data[end_pos]) T(std::forward&lt;Args&gt;(args)...);&#10;            end_pos = (end_pos + 1) % capacity_;&#10;        } else {&#10;            // Buffer is full, need to resize&#10;            resize_up();&#10;            new(&amp;data[end_pos]) T(std::forward&lt;Args&gt;(args)...);&#10;            end_pos = end_pos + 1;&#10;        }&#10;        ++size_;&#10;    }&#10;&#10;    template&lt;typename... Args&gt;&#10;    void emplace_front_impl(Args &amp;&amp;... args) {&#10;        if (size_ &lt; capacity_) [[likely]] {&#10;            begin_pos = begin_pos == 0 ? capacity_ - 1 : begin_pos - 1;&#10;            new(&amp;data[begin_pos]) T(std::forward&lt;Args&gt;(args)...);&#10;        } else {&#10;            // Buffer is full, need to resize&#10;            resize_up();&#10;            begin_pos = capacity_ - 1;&#10;            new(&amp;data[begin_pos]) T(std::forward&lt;Args&gt;(args)...);&#10;        }&#10;        ++size_;&#10;    }&#10;&#10;public:&#10;    explicit CircularBuffer(const size_t _cap = min_cap) : capacity_(_cap) {&#10;        assert(_cap &gt;= 1 &amp;&amp; &quot;Capacity must be at least 1&quot;);&#10;        data_storage = std::unique_ptr&lt;std::byte[], AlignedDeleter&gt;(&#10;            new(std::align_val_t{alignof(T)}) std::byte[_cap * sizeof(T)]&#10;        );&#10;        assert(data_storage &amp;&amp; &quot;Memory allocation failed&quot;);&#10;        data = reinterpret_cast&lt;T *&gt;(data_storage.get());&#10;        begin_pos = 0;&#10;        end_pos = 0;&#10;        size_ = 0;&#10;    }&#10;&#10;    // Rule of 5 Methods&#10;    ~CircularBuffer() {&#10;        for (size_t i = 0; i &lt; size_; ++i) {&#10;            data[(begin_pos + i) % capacity_].~T(); // Explicitly call destructor&#10;        }&#10;    }&#10;&#10;    CircularBuffer &amp;operator=(const CircularBuffer &amp;) = delete;&#10;&#10;    CircularBuffer(const CircularBuffer &amp;) = delete;&#10;&#10;    CircularBuffer &amp;operator=(CircularBuffer &amp;&amp;other) noexcept {&#10;        if (this != &amp;other) {&#10;            for (size_t i = 0; i &lt; size_; ++i) {&#10;                data[(begin_pos + i) % capacity_].~T(); // Explicitly call destructor&#10;            }&#10;            data_storage = std::move(other.data_storage);&#10;            data = other.data;&#10;            begin_pos = other.begin_pos;&#10;            end_pos = other.end_pos;&#10;            size_ = other.size_;&#10;            capacity_ = other.capacity_;&#10;            other.data = nullptr; // Prevent double deletion&#10;        }&#10;        return *this;&#10;    }&#10;&#10;    CircularBuffer(CircularBuffer &amp;&amp;other) noexcept&#10;        : data_storage(std::move(other.data_storage)), data(other.data),&#10;          begin_pos(other.begin_pos), end_pos(other.end_pos), size_(other.size_),&#10;          capacity_(other.capacity_) {&#10;        other.data = nullptr; // Prevent double deletion&#10;    }&#10;&#10;    void push_back(const T &amp;value) requires std::copy_constructible&lt;T&gt; {&#10;        emplace_back_impl(value);&#10;    }&#10;&#10;    void push_back(T &amp;&amp;value) requires std::move_constructible&lt;T&gt; {&#10;        emplace_back_impl(std::move(value));&#10;    }&#10;&#10;    template&lt;typename... Args&gt;&#10;    void emplace_back(Args &amp;&amp;... args) requires std::constructible_from&lt;T,&#10;        Args...&gt; {&#10;        emplace_back_impl(std::forward&lt;Args&gt;(args)...);&#10;    }&#10;&#10;    void push_front(const T &amp;value) requires std::copy_constructible&lt;T&gt; {&#10;        emplace_front_impl(value);&#10;    }&#10;&#10;    void push_front(T &amp;&amp;value) requires std::move_constructible&lt;T&gt; {&#10;        emplace_front_impl(std::move(value));&#10;    }&#10;&#10;    template&lt;typename... Args&gt;&#10;    void emplace_front(Args &amp;&amp;... args) requires std::constructible_from&lt;T,&#10;        Args...&gt; {&#10;        emplace_front_impl(std::forward&lt;Args&gt;(args)...);&#10;    }&#10;&#10;    T pop_back() {&#10;        assert(size_ &gt; 0 &amp;&amp; &quot;Cannot pop from an empty buffer&quot;);&#10;        end_pos = end_pos == 0 ? capacity_ - 1 : end_pos - 1;&#10;        T value = std::move(data[end_pos]);&#10;        data[end_pos].~T();&#10;        --size_;&#10;        if (size_ &lt; capacity_ / 4 &amp;&amp; capacity_ &gt; min_cap) {&#10;            resize_down();&#10;        }&#10;        return value;&#10;    }&#10;&#10;    T pop_front() {&#10;        assert(size_ &gt; 0 &amp;&amp; &quot;Cannot pop from an empty buffer&quot;);&#10;        T value = std::move(data[begin_pos]);&#10;        data[begin_pos].~T(); // Explicitly call destructor&#10;        begin_pos = (begin_pos + 1) % capacity_;&#10;        --size_;&#10;        if (size_ &lt; capacity_ / 4 &amp;&amp; capacity_ &gt; min_cap) {&#10;            resize_down();&#10;        }&#10;        return value;&#10;    }&#10;&#10;    template&lt;typename Self&gt;&#10;    auto &amp;&amp;operator[](this Self &amp;&amp;self, const size_t index) {&#10;        assert(index &lt; self.size_ &amp;&amp; &quot;Index out of bounds&quot;);&#10;        return self.data[(self.begin_pos + index) % self.capacity_];&#10;    }&#10;&#10;    template&lt;typename Self&gt;&#10;    auto &amp;&amp;back(this Self &amp;&amp;self) {&#10;        assert(self.size_ &gt; 0 &amp;&amp; &quot;Buffer is empty&quot;);&#10;        return self.data[(self.end_pos == 0 ? self.capacity_ - 1 : self.end_pos - 1)];&#10;    }&#10;&#10;    template&lt;typename Self&gt;&#10;    auto &amp;&amp;front(this Self &amp;&amp;self) {&#10;        assert(self.size_ &gt; 0 &amp;&amp; &quot;Buffer is empty&quot;);&#10;        return self.data[self.begin_pos];&#10;    }&#10;&#10;    [[nodiscard]] size_t size() const {&#10;        return size_;&#10;    }&#10;&#10;    [[nodiscard]] size_t capacity() const {&#10;        return capacity_;&#10;    }&#10;&#10;    [[nodiscard]] bool empty() const {&#10;        return size_ == 0;&#10;    }&#10;&#10;    struct Iterator {&#10;        CircularBuffer *buffer;&#10;        size_t index;&#10;&#10;        Iterator(CircularBuffer *buf, size_t idx) : buffer(buf), index(idx) {}&#10;&#10;        T&amp; operator*() {&#10;            return buffer-&gt;data[(buffer-&gt;begin_pos + index) % buffer-&gt;capacity_];&#10;        }&#10;&#10;        const T&amp; operator*() const {&#10;            return buffer-&gt;data[(buffer-&gt;begin_pos + index) % buffer-&gt;capacity_];&#10;        }&#10;&#10;        T* operator-&gt;() {&#10;            return &amp;buffer-&gt;data[(buffer-&gt;begin_pos + index) % buffer-&gt;capacity_];&#10;        }&#10;&#10;        const T* operator-&gt;() const {&#10;            return &amp;buffer-&gt;data[(buffer-&gt;begin_pos + index) % buffer-&gt;capacity_];&#10;        }&#10;&#10;        Iterator&amp; operator++() {&#10;            ++index;&#10;            return *this;&#10;        }&#10;&#10;        Iterator operator++(int) {&#10;            Iterator temp = *this;&#10;            ++index;&#10;            return temp;&#10;        }&#10;&#10;        Iterator&amp; operator--() {&#10;            --index;&#10;            return *this;&#10;        }&#10;&#10;        Iterator operator--(int) {&#10;            Iterator temp = *this;&#10;            --index;&#10;            return temp;&#10;        }&#10;&#10;        Iterator operator+(size_t n) const {&#10;            return Iterator(buffer, index + n);&#10;        }&#10;&#10;        Iterator operator-(size_t n) const {&#10;            return Iterator(buffer, index - n);&#10;        }&#10;&#10;        Iterator&amp; operator+=(size_t n) {&#10;            index += n;&#10;            return *this;&#10;        }&#10;&#10;        Iterator&amp; operator-=(size_t n) {&#10;            index -= n;&#10;            return *this;&#10;        }&#10;&#10;        ptrdiff_t operator-(const Iterator&amp; other) const {&#10;            return static_cast&lt;ptrdiff_t&gt;(index) - static_cast&lt;ptrdiff_t&gt;(other.index);&#10;        }&#10;&#10;        bool operator==(const Iterator&amp; other) const {&#10;            return buffer == other.buffer &amp;&amp; index == other.index;&#10;        }&#10;&#10;        bool operator!=(const Iterator&amp; other) const {&#10;            return !(*this == other);&#10;        }&#10;&#10;        bool operator&lt;(const Iterator&amp; other) const {&#10;            return index &lt; other.index;&#10;        }&#10;&#10;        bool operator&lt;=(const Iterator&amp; other) const {&#10;            return index &lt;= other.index;&#10;        }&#10;&#10;        bool operator&gt;(const Iterator&amp; other) const {&#10;            return index &gt; other.index;&#10;        }&#10;&#10;        bool operator&gt;=(const Iterator&amp; other) const {&#10;            return index &gt;= other.index;&#10;        }&#10;    };&#10;&#10;    struct ConstIterator {&#10;        const CircularBuffer *buffer;&#10;        size_t index;&#10;&#10;        ConstIterator(const CircularBuffer *buf, size_t idx) : buffer(buf), index(idx) {}&#10;&#10;        const T&amp; operator*() const {&#10;            return buffer-&gt;data[(buffer-&gt;begin_pos + index) % buffer-&gt;capacity_];&#10;        }&#10;&#10;        const T* operator-&gt;() const {&#10;            return &amp;buffer-&gt;data[(buffer-&gt;begin_pos + index) % buffer-&gt;capacity_];&#10;        }&#10;&#10;        ConstIterator&amp; operator++() {&#10;            ++index;&#10;            return *this;&#10;        }&#10;&#10;        ConstIterator operator++(int) {&#10;            ConstIterator temp = *this;&#10;            ++index;&#10;            return temp;&#10;        }&#10;&#10;        ConstIterator&amp; operator--() {&#10;            --index;&#10;            return *this;&#10;        }&#10;&#10;        ConstIterator operator--(int) {&#10;            ConstIterator temp = *this;&#10;            --index;&#10;            return temp;&#10;        }&#10;&#10;        ConstIterator operator+(size_t n) const {&#10;            return ConstIterator(buffer, index + n);&#10;        }&#10;&#10;        ConstIterator operator-(size_t n) const {&#10;            return ConstIterator(buffer, index - n);&#10;        }&#10;&#10;        ConstIterator&amp; operator+=(size_t n) {&#10;            index += n;&#10;            return *this;&#10;        }&#10;&#10;        ConstIterator&amp; operator-=(size_t n) {&#10;            index -= n;&#10;            return *this;&#10;        }&#10;&#10;        ptrdiff_t operator-(const ConstIterator&amp; other) const {&#10;            return static_cast&lt;ptrdiff_t&gt;(index) - static_cast&lt;ptrdiff_t&gt;(other.index);&#10;        }&#10;&#10;        bool operator==(const ConstIterator&amp; other) const {&#10;            return buffer == other.buffer &amp;&amp; index == other.index;&#10;        }&#10;&#10;        bool operator!=(const ConstIterator&amp; other) const {&#10;            return !(*this == other);&#10;        }&#10;&#10;        bool operator&lt;(const ConstIterator&amp; other) const {&#10;            return index &lt; other.index;&#10;        }&#10;&#10;        bool operator&lt;=(const ConstIterator&amp; other) const {&#10;            return index &lt;= other.index;&#10;        }&#10;&#10;        bool operator&gt;(const ConstIterator&amp; other) const {&#10;            return index &gt; other.index;&#10;        }&#10;&#10;        bool operator&gt;=(const ConstIterator&amp; other) const {&#10;            return index &gt;= other.index;&#10;        }&#10;    };&#10;&#10;    Iterator begin() {&#10;        return Iterator(this, 0);&#10;    }&#10;&#10;    Iterator end() {&#10;        return Iterator(this, size_);&#10;    }&#10;&#10;    ConstIterator begin() const {&#10;        return ConstIterator(this, 0);&#10;    }&#10;&#10;    ConstIterator end() const {&#10;        return ConstIterator(this, size_);&#10;    }&#10;&#10;    ConstIterator cbegin() const {&#10;        return ConstIterator(this, 0);&#10;    }&#10;&#10;    ConstIterator cend() const {&#10;        return ConstIterator(this, size_);&#10;    }&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Deque.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Deque.h" />
              <option name="originalContent" value="/// A Double Ended Queue (Deque)&#10;&#10;#pragma once&#10;&#10;#include &lt;algorithm&gt;&#10;#include &lt;array&gt;&#10;#include &lt;cassert&gt;&#10;#include &lt;cstddef&gt;&#10;#include &lt;memory&gt;&#10;&#10;#include &quot;CircularBuffer.h&quot;&#10;#include &quot;CachingAllocator.h&quot;&#10;&#10;template&lt;typename T&gt;&#10;class Deque {&#10;    static constexpr size_t fixed_arr_n_elem = std::max((4096 + sizeof(T) - 1) / sizeof(T), 16zu);&#10;&#10;    struct alignas(4096) FixedArray {&#10;        // Page aligned&#10;        std::array&lt;std::byte, fixed_arr_n_elem * sizeof(T)&gt; data_storage{};&#10;        T *data{reinterpret_cast&lt;T *&gt;(data_storage.data())};&#10;        FixedArray *next{nullptr};&#10;        FixedArray *prev{nullptr};&#10;&#10;        template&lt;class Self&gt;&#10;        auto &amp;&amp;operator[](this Self &amp;&amp;self, size_t index) {&#10;            assert(index &lt; fixed_arr_n_elem &amp;&amp; &quot;Index out of bounds&quot;);&#10;            return self.data[index];&#10;        }&#10;    };&#10;&#10;    CachingAllocator&lt;FixedArray&gt; allocator{5};&#10;    CircularBuffer&lt;std::unique_ptr&lt;FixedArray, CachingAllocator&lt;FixedArray&gt; &amp;&gt; &gt; buffer{};&#10;    // Implicitly, these are on the first and last FixedArray, which may be the same&#10;    size_t first_idx = 0; // inv: 0 &lt;= first_idx &lt; fixed_arr_n_elem&#10;    size_t last_idx = 0; // inv: 0 &lt; last_idx &lt;= fixed_arr_n_elem&#10;    size_t size_{0};&#10;&#10;    template&lt;typename... Args&gt;&#10;    void emplace_front_impl(Args &amp;&amp;... value) {&#10;        if (first_idx == 0) [[unlikely]] {&#10;            FixedArray *first_array_ptr = buffer.front().get();&#10;            buffer.push_front(allocator.allocate());&#10;            buffer.front()-&gt;next = first_array_ptr;&#10;            first_array_ptr-&gt;prev = buffer.front().get();&#10;            first_idx = fixed_arr_n_elem;&#10;        }&#10;        FixedArray &amp;first_array = *buffer.front();&#10;        --first_idx;&#10;        new(&amp;first_array[first_idx]) T(std::forward&lt;Args&gt;(value)...);&#10;        ++size_;&#10;    }&#10;&#10;    template&lt;typename... Args&gt;&#10;    void emplace_back_impl(Args &amp;&amp;... value) {&#10;        if (last_idx == fixed_arr_n_elem) [[unlikely]] {&#10;            FixedArray *last_array_ptr = buffer.back().get();&#10;            buffer.push_back(allocator.allocate());&#10;            buffer.back()-&gt;prev = last_array_ptr;&#10;            last_array_ptr-&gt;next = buffer.back().get();&#10;            last_idx = 0;&#10;        }&#10;        FixedArray &amp;last_array = *buffer.back();&#10;        new(&amp;last_array[last_idx]) T(std::forward&lt;Args&gt;(value)...);&#10;        ++last_idx;&#10;        ++size_;&#10;    }&#10;&#10;    struct Iterator {&#10;        Deque *deque{};&#10;        FixedArray *current_array{};&#10;        size_t index{};&#10;&#10;        T &amp;operator*() {&#10;            return current_array-&gt;data[index];&#10;        }&#10;&#10;        [[nodiscard]] Iterator next() const {&#10;            if (current_array == nullptr) [[unlikely]] {&#10;                return *this; // Already at end&#10;            }&#10;            if (index == deque-&gt;last_idx - 1 &amp;&amp; current_array == deque-&gt;buffer.back().get()) [[unlikely]] {&#10;                return Iterator{deque, nullptr, 0}; // Move to end&#10;            }&#10;&#10;            if (index == fixed_arr_n_elem - 1) {&#10;                return Iterator{deque, current_array-&gt;next, 0}; // Move to next array&#10;            }&#10;&#10;&#10;            return Iterator{deque, current_array, index + 1};&#10;        }&#10;&#10;        [[nodiscard]] Iterator prev() const {&#10;            if (current_array == nullptr) {&#10;                // Coming from end, go to last valid element&#10;                return Iterator{deque, deque-&gt;buffer.back().get(), deque-&gt;last_idx - 1};&#10;            }&#10;&#10;            // Check if we're at the first element of the deque&#10;            if (current_array == deque-&gt;buffer.front().get() &amp;&amp; index == deque-&gt;first_idx) {&#10;                return Iterator{deque, nullptr, 0}; // Before begin (invalid)&#10;            }&#10;&#10;            // Move to previous position in current array&#10;            if (index &gt; 0) {&#10;                return Iterator{deque, current_array, index - 1};&#10;            }&#10;&#10;            // Move to previous array&#10;            return Iterator{deque, current_array-&gt;prev, fixed_arr_n_elem - 1};&#10;        }&#10;&#10;        Iterator &amp;operator++() {&#10;            *this = next();&#10;            return *this;&#10;        }&#10;&#10;        Iterator operator++(int) {&#10;            Iterator temp = *this;&#10;            ++(*this);&#10;            return temp;&#10;        }&#10;&#10;        Iterator &amp;operator--() {&#10;            *this = prev();&#10;            return *this;&#10;        }&#10;&#10;        Iterator operator--(int) {&#10;            Iterator temp = *this;&#10;            --(*this);&#10;            return temp;&#10;        }&#10;&#10;        // Equality operators needed for range-based for loops&#10;        bool operator==(const Iterator &amp;other) const {&#10;            return deque == other.deque &amp;&amp;&#10;                   current_array == other.current_array &amp;&amp;&#10;                   index == other.index;&#10;        }&#10;&#10;        bool operator!=(const Iterator &amp;other) const {&#10;            return !(*this == other);&#10;        }&#10;    };&#10;&#10;public:&#10;    Deque() {&#10;        buffer.push_back(allocator.allocate());&#10;    }&#10;&#10;    Deque(std::initializer_list&lt;T&gt; init) {&#10;        buffer.push_back(allocator.allocate());&#10;        for (const auto &amp;value: init) {&#10;            emplace_back_impl(value);&#10;        }&#10;    }&#10;&#10;    // Rule of 5 Methods&#10;    ~Deque() {&#10;        for (T&amp; item: *this) {&#10;            item.~T(); // Explicitly call destructor for each element&#10;        }&#10;    }&#10;&#10;    Deque(const Deque &amp;other) = delete;&#10;    Deque &amp;operator=(const Deque &amp;other) = delete;&#10;    Deque(Deque &amp;&amp;other) noexcept&#10;        : allocator(std::move(other.allocator)), buffer(std::move(other.buffer)),&#10;          first_idx(other.first_idx), last_idx(other.last_idx), size_(other.size_) {&#10;        other.first_idx = 0;&#10;        other.last_idx = 0;&#10;        other.size_ = 0;&#10;    }&#10;&#10;    Deque &amp;operator=(Deque &amp;&amp;other) noexcept {&#10;        if (this != &amp;other) {&#10;            // Properly destroy existing elements&#10;            for (T&amp; item: *this) {&#10;                item.~T();&#10;            }&#10;&#10;            // Since CachingAllocator and CircularBuffer don't have proper move assignment,&#10;            // we need to reconstruct this object using the move constructor approach&#10;            this-&gt;~Deque(); // Properly destroy this object&#10;            &#10;            // Use placement new to reconstruct using move constructor&#10;            new (this) Deque(std::move(other));&#10;        }&#10;        return *this;&#10;    }&#10;&#10;&#10;    void push_back(const T &amp;value) requires std::copy_constructible&lt;T&gt; {&#10;        emplace_back_impl(value);&#10;    }&#10;&#10;    void push_back(T &amp;&amp;value) requires std::move_constructible&lt;T&gt; {&#10;        emplace_back_impl(std::move(value));&#10;    }&#10;&#10;    template&lt;typename... Args&gt;&#10;    void emplace_back(Args &amp;&amp;... args) requires std::constructible_from&lt;T, Args...&gt; {&#10;        emplace_back_impl(std::forward&lt;Args&gt;(args)...);&#10;    }&#10;&#10;    void push_front(const T &amp;value) requires std::copy_constructible&lt;T&gt; {&#10;        emplace_front_impl(value);&#10;    }&#10;&#10;    void push_front(T &amp;&amp;value) requires std::move_constructible&lt;T&gt; {&#10;        emplace_front_impl(std::move(value));&#10;    }&#10;&#10;    template&lt;typename... Args&gt;&#10;    void emplace_front(Args &amp;&amp;... args) requires std::constructible_from&lt;T, Args...&gt; {&#10;        emplace_front_impl(std::forward&lt;Args&gt;(args)...);&#10;    }&#10;&#10;    T pop_back() {&#10;        assert(size_ &gt; 0 &amp;&amp; &quot;Cannot pop from an empty deque&quot;);&#10;        --size_;&#10;        --last_idx;&#10;        FixedArray &amp;last_array = *buffer.back();&#10;        T value = std::move(last_array[last_idx]);&#10;        if (last_idx == 0) [[unlikely]] {&#10;            // Remove the last FixedArray if it is empty&#10;            buffer.pop_back();&#10;            last_idx = fixed_arr_n_elem;&#10;        }&#10;        return value;&#10;    }&#10;&#10;    T pop_front() {&#10;        assert(size_ &gt; 0 &amp;&amp; &quot;Cannot pop from an empty deque&quot;);&#10;        --size_;&#10;        FixedArray &amp;first_array = *buffer.front();&#10;        T value = std::move(first_array[first_idx]);&#10;        ++first_idx;&#10;        if (first_idx == fixed_arr_n_elem) [[unlikely]] {&#10;            // Remove the first FixedArray if it is empty&#10;            buffer.pop_front();&#10;            first_idx = 0; // Reset to the start of the next FixedArray&#10;        }&#10;        return value;&#10;    }&#10;&#10;    template&lt;class Self&gt;&#10;    auto &amp;&amp;operator[](this Self &amp;&amp;self, const size_t index) {&#10;        assert(index &lt; self.size_ &amp;&amp; &quot;Index out of bounds&quot;);&#10;&#10;        const size_t first_size = fixed_arr_n_elem - self.first_idx;&#10;        if (index &lt; first_size) {&#10;            // Access within the first FixedArray&#10;            return (*self.buffer.front())[self.first_idx + index];&#10;        }&#10;&#10;        const size_t adjusted_index = index - first_size;&#10;        const size_t num_full_arrays = adjusted_index / fixed_arr_n_elem;&#10;        const size_t index_in_array = adjusted_index % fixed_arr_n_elem;&#10;        return (*self.buffer[num_full_arrays + 1])[index_in_array];&#10;    }&#10;&#10;    template&lt;typename Self&gt;&#10;    auto &amp;&amp;back(this Self &amp;&amp;self) {&#10;        assert(self.size_ &gt; 0 &amp;&amp; &quot;Deque is empty&quot;);&#10;        return (*self.buffer.back())[self.last_idx - 1];&#10;    }&#10;&#10;    template&lt;typename Self&gt;&#10;    auto &amp;&amp;front(this Self &amp;&amp;self) {&#10;        assert(self.size_ &gt; 0 &amp;&amp; &quot;Deque is empty&quot;);&#10;        return (*self.buffer.front())[self.first_idx];&#10;    }&#10;&#10;    Iterator end() {&#10;        return Iterator{this, nullptr, 0}; // End of iteration&#10;    }&#10;&#10;    Iterator begin() {&#10;        if (size_ == 0) [[unlikely]] {&#10;            return end(); // Empty deque&#10;        }&#10;        return Iterator{this, buffer.front().get(), first_idx};&#10;    }&#10;&#10;    [[nodiscard]] size_t size() const {&#10;        return size_;&#10;    }&#10;&#10;    [[nodiscard]] bool empty() const {&#10;        return size_ == 0;&#10;    }&#10;};&#10;&#10;// Explicit template instantiations for common types&#10;template class Deque&lt;int&gt;;&#10;template class Deque&lt;std::string&gt;;&#10;" />
              <option name="updatedContent" value="/// A Double Ended Queue (Deque)&#10;&#10;#pragma once&#10;&#10;#include &lt;algorithm&gt;&#10;#include &lt;array&gt;&#10;#include &lt;cassert&gt;&#10;#include &lt;cstddef&gt;&#10;#include &lt;memory&gt;&#10;&#10;#include &quot;CircularBuffer.h&quot;&#10;#include &quot;CachingAllocator.h&quot;&#10;&#10;template&lt;typename T&gt;&#10;class Deque {&#10;    static constexpr size_t fixed_arr_n_elem = std::max((4096 + sizeof(T) - 1) / sizeof(T), 16zu);&#10;&#10;    struct alignas(4096) FixedArray {&#10;        // Page aligned&#10;        std::array&lt;std::byte, fixed_arr_n_elem * sizeof(T)&gt; data_storage{};&#10;        T *data{reinterpret_cast&lt;T *&gt;(data_storage.data())};&#10;        FixedArray *next{nullptr};&#10;        FixedArray *prev{nullptr};&#10;&#10;        template&lt;class Self&gt;&#10;        auto &amp;&amp;operator[](this Self &amp;&amp;self, size_t index) {&#10;            assert(index &lt; fixed_arr_n_elem &amp;&amp; &quot;Index out of bounds&quot;);&#10;            return self.data[index];&#10;        }&#10;    };&#10;&#10;    CachingAllocator&lt;FixedArray&gt; allocator{5};&#10;    CircularBuffer&lt;std::unique_ptr&lt;FixedArray, CachingAllocator&lt;FixedArray&gt; &amp;&gt; &gt; buffer{};&#10;    // Implicitly, these are on the first and last FixedArray, which may be the same&#10;    size_t first_idx = 0; // inv: 0 &lt;= first_idx &lt; fixed_arr_n_elem&#10;    size_t last_idx = 0; // inv: 0 &lt; last_idx &lt;= fixed_arr_n_elem&#10;    size_t size_{0};&#10;&#10;    template&lt;typename... Args&gt;&#10;    void emplace_front_impl(Args &amp;&amp;... value) {&#10;        if (first_idx == 0) [[unlikely]] {&#10;            FixedArray *first_array_ptr = buffer.front().get();&#10;            buffer.push_front(allocator.allocate());&#10;            buffer.front()-&gt;next = first_array_ptr;&#10;            first_array_ptr-&gt;prev = buffer.front().get();&#10;            first_idx = fixed_arr_n_elem;&#10;        }&#10;        FixedArray &amp;first_array = *buffer.front();&#10;        --first_idx;&#10;        new(&amp;first_array[first_idx]) T(std::forward&lt;Args&gt;(value)...);&#10;        ++size_;&#10;    }&#10;&#10;    template&lt;typename... Args&gt;&#10;    void emplace_back_impl(Args &amp;&amp;... value) {&#10;        if (last_idx == fixed_arr_n_elem) [[unlikely]] {&#10;            FixedArray *last_array_ptr = buffer.back().get();&#10;            buffer.push_back(allocator.allocate());&#10;            buffer.back()-&gt;prev = last_array_ptr;&#10;            last_array_ptr-&gt;next = buffer.back().get();&#10;            last_idx = 0;&#10;        }&#10;        FixedArray &amp;last_array = *buffer.back();&#10;        new(&amp;last_array[last_idx]) T(std::forward&lt;Args&gt;(value)...);&#10;        ++last_idx;&#10;        ++size_;&#10;    }&#10;&#10;    struct Iterator {&#10;        Deque *deque{};&#10;        FixedArray *current_array{};&#10;        size_t index{};&#10;&#10;        T &amp;operator*() {&#10;            return current_array-&gt;data[index];&#10;        }&#10;&#10;        [[nodiscard]] Iterator next() const {&#10;            if (current_array == nullptr) [[unlikely]] {&#10;                return *this; // Already at end&#10;            }&#10;            if (index == deque-&gt;last_idx - 1 &amp;&amp; current_array == deque-&gt;buffer.back().get()) [[unlikely]] {&#10;                return Iterator{deque, nullptr, 0}; // Move to end&#10;            }&#10;&#10;            if (index == fixed_arr_n_elem - 1) {&#10;                return Iterator{deque, current_array-&gt;next, 0}; // Move to next array&#10;            }&#10;&#10;&#10;            return Iterator{deque, current_array, index + 1};&#10;        }&#10;&#10;        [[nodiscard]] Iterator prev() const {&#10;            if (current_array == nullptr) {&#10;                // Coming from end, go to last valid element&#10;                return Iterator{deque, deque-&gt;buffer.back().get(), deque-&gt;last_idx - 1};&#10;            }&#10;&#10;            // Check if we're at the first element of the deque&#10;            if (current_array == deque-&gt;buffer.front().get() &amp;&amp; index == deque-&gt;first_idx) {&#10;                return Iterator{deque, nullptr, 0}; // Before begin (invalid)&#10;            }&#10;&#10;            // Move to previous position in current array&#10;            if (index &gt; 0) {&#10;                return Iterator{deque, current_array, index - 1};&#10;            }&#10;&#10;            // Move to previous array&#10;            return Iterator{deque, current_array-&gt;prev, fixed_arr_n_elem - 1};&#10;        }&#10;&#10;        Iterator &amp;operator++() {&#10;            *this = next();&#10;            return *this;&#10;        }&#10;&#10;        Iterator operator++(int) {&#10;            Iterator temp = *this;&#10;            ++(*this);&#10;            return temp;&#10;        }&#10;&#10;        Iterator &amp;operator--() {&#10;            *this = prev();&#10;            return *this;&#10;        }&#10;&#10;        Iterator operator--(int) {&#10;            Iterator temp = *this;&#10;            --(*this);&#10;            return temp;&#10;        }&#10;&#10;        // Equality operators needed for range-based for loops&#10;        bool operator==(const Iterator &amp;other) const {&#10;            return deque == other.deque &amp;&amp;&#10;                   current_array == other.current_array &amp;&amp;&#10;                   index == other.index;&#10;        }&#10;&#10;        bool operator!=(const Iterator &amp;other) const {&#10;            return !(*this == other);&#10;        }&#10;    };&#10;&#10;public:&#10;    Deque() {&#10;        buffer.push_back(allocator.allocate());&#10;    }&#10;&#10;    Deque(std::initializer_list&lt;T&gt; init) {&#10;        buffer.push_back(allocator.allocate());&#10;        for (const auto &amp;value: init) {&#10;            emplace_back_impl(value);&#10;        }&#10;    }&#10;&#10;    // Rule of 5 Methods&#10;    ~Deque() {&#10;        for (T&amp; item: *this) {&#10;            item.~T(); // Explicitly call destructor for each element&#10;        }&#10;    }&#10;&#10;    Deque(const Deque &amp;other) = delete;&#10;    Deque &amp;operator=(const Deque &amp;other) = delete;&#10;    Deque(Deque &amp;&amp;other) noexcept&#10;        : allocator(std::move(other.allocator)), buffer(std::move(other.buffer)),&#10;          first_idx(other.first_idx), last_idx(other.last_idx), size_(other.size_) {&#10;        other.first_idx = 0;&#10;        other.last_idx = 0;&#10;        other.size_ = 0;&#10;    }&#10;&#10;    Deque &amp;operator=(Deque &amp;&amp;other) noexcept {&#10;        if (this != &amp;other) {&#10;            // Properly destroy existing elements&#10;            for (T&amp; item: *this) {&#10;                item.~T();&#10;            }&#10;&#10;            // Since CachingAllocator and CircularBuffer don't have proper move assignment,&#10;            // we need to reconstruct this object using the move constructor approach&#10;            this-&gt;~Deque(); // Properly destroy this object&#10;            &#10;            // Use placement new to reconstruct using move constructor&#10;            new (this) Deque(std::move(other));&#10;        }&#10;        return *this;&#10;    }&#10;&#10;&#10;    void push_back(const T &amp;value) requires std::copy_constructible&lt;T&gt; {&#10;        emplace_back_impl(value);&#10;    }&#10;&#10;    void push_back(T &amp;&amp;value) requires std::move_constructible&lt;T&gt; {&#10;        emplace_back_impl(std::move(value));&#10;    }&#10;&#10;    template&lt;typename... Args&gt;&#10;    void emplace_back(Args &amp;&amp;... args) requires std::constructible_from&lt;T, Args...&gt; {&#10;        emplace_back_impl(std::forward&lt;Args&gt;(args)...);&#10;    }&#10;&#10;    void push_front(const T &amp;value) requires std::copy_constructible&lt;T&gt; {&#10;        emplace_front_impl(value);&#10;    }&#10;&#10;    void push_front(T &amp;&amp;value) requires std::move_constructible&lt;T&gt; {&#10;        emplace_front_impl(std::move(value));&#10;    }&#10;&#10;    template&lt;typename... Args&gt;&#10;    void emplace_front(Args &amp;&amp;... args) requires std::constructible_from&lt;T, Args...&gt; {&#10;        emplace_front_impl(std::forward&lt;Args&gt;(args)...);&#10;    }&#10;&#10;    T pop_back() {&#10;        assert(size_ &gt; 0 &amp;&amp; &quot;Cannot pop from an empty deque&quot;);&#10;        --size_;&#10;        --last_idx;&#10;        FixedArray &amp;last_array = *buffer.back();&#10;        T value = std::move(last_array[last_idx]);&#10;        if (last_idx == 0) [[unlikely]] {&#10;            // Remove the last FixedArray if it is empty&#10;            buffer.pop_back();&#10;            last_idx = fixed_arr_n_elem;&#10;        }&#10;        return value;&#10;    }&#10;&#10;    T pop_front() {&#10;        assert(size_ &gt; 0 &amp;&amp; &quot;Cannot pop from an empty deque&quot;);&#10;        --size_;&#10;        FixedArray &amp;first_array = *buffer.front();&#10;        T value = std::move(first_array[first_idx]);&#10;        ++first_idx;&#10;        if (first_idx == fixed_arr_n_elem) [[unlikely]] {&#10;            // Remove the first FixedArray if it is empty&#10;            buffer.pop_front();&#10;            first_idx = 0; // Reset to the start of the next FixedArray&#10;        }&#10;        return value;&#10;    }&#10;&#10;    template&lt;class Self&gt;&#10;    auto &amp;&amp;operator[](this Self &amp;&amp;self, const size_t index) {&#10;        assert(index &lt; self.size_ &amp;&amp; &quot;Index out of bounds&quot;);&#10;&#10;        const size_t first_size = fixed_arr_n_elem - self.first_idx;&#10;        if (index &lt; first_size) {&#10;            // Access within the first FixedArray&#10;            return (*self.buffer.front())[self.first_idx + index];&#10;        }&#10;&#10;        const size_t adjusted_index = index - first_size;&#10;        const size_t num_full_arrays = adjusted_index / fixed_arr_n_elem;&#10;        const size_t index_in_array = adjusted_index % fixed_arr_n_elem;&#10;        return (*self.buffer[num_full_arrays + 1])[index_in_array];&#10;    }&#10;&#10;    template&lt;typename Self&gt;&#10;    auto &amp;&amp;back(this Self &amp;&amp;self) {&#10;        assert(self.size_ &gt; 0 &amp;&amp; &quot;Deque is empty&quot;);&#10;        return (*self.buffer.back())[self.last_idx - 1];&#10;    }&#10;&#10;    template&lt;typename Self&gt;&#10;    auto &amp;&amp;front(this Self &amp;&amp;self) {&#10;        assert(self.size_ &gt; 0 &amp;&amp; &quot;Deque is empty&quot;);&#10;        return (*self.buffer.front())[self.first_idx];&#10;    }&#10;&#10;    Iterator end() {&#10;        return Iterator{this, nullptr, 0}; // End of iteration&#10;    }&#10;&#10;    Iterator begin() {&#10;        if (size_ == 0) [[unlikely]] {&#10;            return end(); // Empty deque&#10;        }&#10;        return Iterator{this, buffer.front().get(), first_idx};&#10;    }&#10;&#10;    [[nodiscard]] size_t size() const {&#10;        return size_;&#10;    }&#10;&#10;    [[nodiscard]] bool empty() const {&#10;        return size_ == 0;&#10;    }&#10;};&#10;&#10;// Explicit template instantiations for common types&#10;template class Deque&lt;int&gt;;&#10;template class Deque&lt;std::string&gt;;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/TestingTracker.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/TestingTracker.cpp" />
              <option name="updatedContent" value="#include &quot;TestingTracker.h&quot;&#10;&#10;int TestingTracker::constructed = 0;&#10;int TestingTracker::destructed = 0;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/TestingTracker.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/TestingTracker.h" />
              <option name="originalContent" value="#pragma once&#10;class TestingTracker {&#10;public:&#10;    static int constructed;&#10;    static int destructed;&#10;&#10;    TestingTracker() {&#10;        constructed++;&#10;    }&#10;&#10;    TestingTracker(const TestingTracker &amp;) {&#10;        constructed++;&#10;    }&#10;&#10;    ~TestingTracker() {&#10;        destructed++;&#10;    }&#10;};&#10;&#10;int TestingTracker::constructed = 0;&#10;int TestingTracker::destructed = 0;&#10;" />
              <option name="updatedContent" value="#pragma once&#10;class TestingTracker {&#10;public:&#10;    static int constructed;&#10;    static int destructed;&#10;&#10;    TestingTracker() {&#10;        constructed++;&#10;    }&#10;&#10;    TestingTracker(const TestingTracker &amp;) {&#10;        constructed++;&#10;    }&#10;&#10;    ~TestingTracker() {&#10;        destructed++;&#10;    }&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/test_circular_buffer.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/test_circular_buffer.cpp" />
              <option name="originalContent" value="#include &lt;catch2/catch_test_macros.hpp&gt;&#10;#include &quot;CircularBuffer.h&quot;&#10;#include &quot;TestingTracker.h&quot;&#10;&#10;TEST_CASE(&quot;CircularBuffer construction&quot;, &quot;[CircularBuffer]&quot;) {&#10;    SECTION(&quot;Create buffer with capacity&quot;) {&#10;        CircularBuffer&lt;int&gt; buffer{100};&#10;        REQUIRE(true); // Constructor should not throw&#10;    }&#10;}&#10;&#10;TEST_CASE(&quot;CircularBuffer push_back&quot;, &quot;[CircularBuffer]&quot;) {&#10;    CircularBuffer&lt;int&gt; buffer(3);&#10;&#10;    SECTION(&quot;Push elements within capacity&quot;) {&#10;        REQUIRE_NOTHROW(buffer.push_back(1));&#10;        REQUIRE_NOTHROW(buffer.push_back(2));&#10;        REQUIRE_NOTHROW(buffer.push_back(3));&#10;        REQUIRE(buffer.size() == 3);&#10;    }&#10;&#10;    SECTION(&quot;Push beyond capacity should resize&quot;) {&#10;        buffer.push_back(1);&#10;        buffer.push_back(2);&#10;        buffer.push_back(3);&#10;        buffer.push_back(4);&#10;&#10;        REQUIRE(buffer.size() == 4);&#10;    }&#10;}&#10;&#10;TEST_CASE(&quot;CircularBuffer with strings&quot;, &quot;[CircularBuffer]&quot;) {&#10;    CircularBuffer&lt;std::string&gt; buffer(2);&#10;&#10;    SECTION(&quot;Push string elements&quot;) {&#10;        REQUIRE_NOTHROW(buffer.push_back(&quot;hello&quot;));&#10;        REQUIRE_NOTHROW(buffer.push_back(&quot;world&quot;));&#10;        buffer.pop_back();&#10;        buffer.pop_back();&#10;    }&#10;}&#10;&#10;TEST_CASE(&quot;CircularBuffer resizing and operator[]&quot;, &quot;[CircularBuffer]&quot;) {&#10;    CircularBuffer&lt;int&gt; buffer(4);&#10;&#10;    SECTION(&quot;Upward resizing maintains order and size&quot;) {&#10;        for (int i = 0; i &lt; 20; ++i) {&#10;            buffer.push_back(i);&#10;        }&#10;        REQUIRE(buffer.size() == 20);&#10;        for (int i = 0; i &lt; 20; ++i) {&#10;            REQUIRE(buffer[i] == i);&#10;        }&#10;        REQUIRE(buffer.capacity() &gt;= 20);&#10;    }&#10;&#10;    SECTION(&quot;Downward resizing maintains order and size&quot;) {&#10;        for (int i = 0; i &lt; 32; ++i) {&#10;            buffer.push_back(i);&#10;        }&#10;        for (int i = 0; i &lt; 28; ++i) {&#10;            buffer.pop_front();&#10;        }&#10;        REQUIRE(buffer.size() == 4);&#10;        for (int i = 0; i &lt; 4; ++i) {&#10;            REQUIRE(buffer[i] == 28 + i);&#10;        }&#10;        REQUIRE(buffer.capacity() &lt;= 32);&#10;    }&#10;&#10;    SECTION(&quot;operator[] works after wraparound and resize&quot;) {&#10;        for (int i = 0; i &lt; 8; ++i) {&#10;            buffer.push_back(i);&#10;        }&#10;        for (int i = 0; i &lt; 4; ++i) {&#10;            buffer.pop_front();&#10;        }&#10;        for (int i = 8; i &lt; 12; ++i) {&#10;            buffer.push_back(i);&#10;        }&#10;        // Buffer now contains 4..11&#10;        for (int i = 0; i &lt; buffer.size(); ++i) {&#10;            REQUIRE(buffer[i] == 4 + i);&#10;        }&#10;    }&#10;}&#10;&#10;TEST_CASE(&quot;CircularBuffer robustness tests&quot;, &quot;[CircularBuffer][Robustness]&quot;) {&#10;    SECTION(&quot;Multiple upward resizes maintain correctness&quot;) {&#10;        CircularBuffer&lt;int&gt; buffer(8);&#10;&#10;        // Fill buffer to trigger multiple resizes&#10;        for (int i = 0; i &lt; 1000; ++i) {&#10;            buffer.push_back(i);&#10;        }&#10;&#10;        REQUIRE(buffer.size() == 1000);&#10;        REQUIRE(buffer.capacity() &gt;= 1000);&#10;&#10;        // Verify all elements are correct and accessible&#10;        for (int i = 0; i &lt; 1000; ++i) {&#10;            REQUIRE(buffer[i] == i);&#10;        }&#10;&#10;        // Verify front and back work correctly&#10;        REQUIRE(buffer.front() == 0);&#10;        REQUIRE(buffer.back() == 999);&#10;    }&#10;&#10;    SECTION(&quot;Multiple downward resizes maintain correctness&quot;) {&#10;        CircularBuffer&lt;int&gt; buffer(8);&#10;&#10;        // Fill buffer with many elements&#10;        for (int i = 0; i &lt; 1000; ++i) {&#10;            buffer.push_back(i);&#10;        }&#10;&#10;        // Remove most elements to trigger downward resizing&#10;        for (int i = 0; i &lt; 990; ++i) {&#10;            buffer.pop_front();&#10;        }&#10;&#10;        REQUIRE(buffer.size() == 10);&#10;        // Capacity should have decreased significantly&#10;        REQUIRE(buffer.capacity() &lt; 1000);&#10;&#10;        // Verify remaining elements are correct&#10;        for (int i = 0; i &lt; 10; ++i) {&#10;            REQUIRE(buffer[i] == 990 + i);&#10;        }&#10;&#10;        REQUIRE(buffer.front() == 990);&#10;        REQUIRE(buffer.back() == 999);&#10;    }&#10;&#10;    SECTION(&quot;Mixed operations with complex wraparound&quot;) {&#10;        CircularBuffer&lt;int&gt; buffer(16);&#10;&#10;        // Create complex pattern that causes wraparound&#10;        for (int cycle = 0; cycle &lt; 20; ++cycle) {&#10;            // Add elements&#10;            for (int i = 0; i &lt; 30; ++i) {&#10;                buffer.push_back(cycle * 100 + i);&#10;            }&#10;&#10;            // Remove some from front&#10;            for (int i = 0; i &lt; 15; ++i) {&#10;                buffer.pop_front();&#10;            }&#10;&#10;            // Add some to front&#10;            for (int i = 0; i &lt; 5; ++i) {&#10;                buffer.push_front(-(cycle * 100 + i + 1));&#10;            }&#10;&#10;            // Remove some from back&#10;            for (int i = 0; i &lt; 10; ++i) {&#10;                buffer.pop_back();&#10;            }&#10;        }&#10;&#10;        // Buffer should still be functional&#10;        REQUIRE(buffer.size() &gt; 0);&#10;&#10;        // operator[] should work for all valid indices&#10;        for (size_t i = 0; i &lt; buffer.size(); ++i) {&#10;            REQUIRE_NOTHROW(buffer[i]);&#10;        }&#10;&#10;        // front() and back() should work&#10;        REQUIRE_NOTHROW(buffer.front());&#10;        REQUIRE_NOTHROW(buffer.back());&#10;    }&#10;&#10;    SECTION(&quot;Size is maintained correctly through all operations&quot;) {&#10;        CircularBuffer&lt;int&gt; buffer(4);&#10;        size_t expected_size = 0;&#10;&#10;        // Push back operations&#10;        for (int i = 0; i &lt; 50; ++i) {&#10;            buffer.push_back(i);&#10;            ++expected_size;&#10;            REQUIRE(buffer.size() == expected_size);&#10;        }&#10;&#10;        // Push front operations&#10;        for (int i = 0; i &lt; 30; ++i) {&#10;            buffer.push_front(-i);&#10;            ++expected_size;&#10;            REQUIRE(buffer.size() == expected_size);&#10;        }&#10;&#10;        // Pop back operations&#10;        for (int i = 0; i &lt; 25; ++i) {&#10;            buffer.pop_back();&#10;            --expected_size;&#10;            REQUIRE(buffer.size() == expected_size);&#10;        }&#10;&#10;        // Pop front operations&#10;        for (int i = 0; i &lt; 25; ++i) {&#10;            buffer.pop_front();&#10;            --expected_size;&#10;            REQUIRE(buffer.size() == expected_size);&#10;        }&#10;&#10;        REQUIRE(expected_size == 30);&#10;        REQUIRE(buffer.size() == 30);&#10;    }&#10;&#10;    SECTION(&quot;operator[] correctness after resize operations&quot;) {&#10;        CircularBuffer&lt;int&gt; buffer(4);&#10;&#10;        // Fill with pattern&#10;        for (int i = 0; i &lt; 20; ++i) {&#10;            buffer.push_back(i * 3); // 0, 3, 6, 9, 12, ...&#10;        }&#10;&#10;        // Verify pattern after upward resize&#10;        for (int i = 0; i &lt; 20; ++i) {&#10;            REQUIRE(buffer[i] == i * 3);&#10;        }&#10;&#10;        // Remove elements from front to trigger potential downward resize&#10;        for (int i = 0; i &lt; 15; ++i) {&#10;            buffer.pop_front();&#10;        }&#10;&#10;        // Verify remaining elements are still correct&#10;        REQUIRE(buffer.size() == 5);&#10;        for (int i = 0; i &lt; 5; ++i) {&#10;            REQUIRE(buffer[i] == (15 + i) * 3); // Should be 45, 48, 51, 54, 57&#10;        }&#10;    }&#10;}&#10;&#10;TEST_CASE(&quot;CircularBuffer element construction/destruction count&quot;, &quot;[CircularBuffer][Lifetime]&quot;) {&#10;    TestingTracker::constructed = 0;&#10;    TestingTracker::destructed = 0;&#10;&#10;    constexpr int num_elements = 50; {&#10;        CircularBuffer&lt;TestingTracker&gt; buffer(8);&#10;        for (int i = 0; i &lt; num_elements; ++i) {&#10;            buffer.emplace_back();&#10;        }&#10;&#10;        REQUIRE(TestingTracker::constructed == num_elements);&#10;    }&#10;&#10;    REQUIRE(TestingTracker::destructed == num_elements);&#10;}&#10;" />
              <option name="updatedContent" value="#include &lt;catch2/catch_test_macros.hpp&gt;&#10;#include &quot;CircularBuffer.h&quot;&#10;#include &quot;TestingTracker.h&quot;&#10;&#10;TEST_CASE(&quot;CircularBuffer construction&quot;, &quot;[CircularBuffer]&quot;) {&#10;    SECTION(&quot;Create buffer with capacity&quot;) {&#10;        CircularBuffer&lt;int&gt; buffer{100};&#10;        REQUIRE(true); // Constructor should not throw&#10;    }&#10;}&#10;&#10;TEST_CASE(&quot;CircularBuffer push_back&quot;, &quot;[CircularBuffer]&quot;) {&#10;    CircularBuffer&lt;int&gt; buffer(3);&#10;&#10;    SECTION(&quot;Push elements within capacity&quot;) {&#10;        REQUIRE_NOTHROW(buffer.push_back(1));&#10;        REQUIRE_NOTHROW(buffer.push_back(2));&#10;        REQUIRE_NOTHROW(buffer.push_back(3));&#10;        REQUIRE(buffer.size() == 3);&#10;    }&#10;&#10;    SECTION(&quot;Push beyond capacity should resize&quot;) {&#10;        buffer.push_back(1);&#10;        buffer.push_back(2);&#10;        buffer.push_back(3);&#10;        buffer.push_back(4);&#10;&#10;        REQUIRE(buffer.size() == 4);&#10;    }&#10;}&#10;&#10;TEST_CASE(&quot;CircularBuffer with strings&quot;, &quot;[CircularBuffer]&quot;) {&#10;    CircularBuffer&lt;std::string&gt; buffer(2);&#10;&#10;    SECTION(&quot;Push string elements&quot;) {&#10;        REQUIRE_NOTHROW(buffer.push_back(&quot;hello&quot;));&#10;        REQUIRE_NOTHROW(buffer.push_back(&quot;world&quot;));&#10;        buffer.pop_back();&#10;        buffer.pop_back();&#10;    }&#10;}&#10;&#10;TEST_CASE(&quot;CircularBuffer resizing and operator[]&quot;, &quot;[CircularBuffer]&quot;) {&#10;    CircularBuffer&lt;int&gt; buffer(4);&#10;&#10;    SECTION(&quot;Upward resizing maintains order and size&quot;) {&#10;        for (int i = 0; i &lt; 20; ++i) {&#10;            buffer.push_back(i);&#10;        }&#10;        REQUIRE(buffer.size() == 20);&#10;        for (int i = 0; i &lt; 20; ++i) {&#10;            REQUIRE(buffer[i] == i);&#10;        }&#10;        REQUIRE(buffer.capacity() &gt;= 20);&#10;    }&#10;&#10;    SECTION(&quot;Downward resizing maintains order and size&quot;) {&#10;        for (int i = 0; i &lt; 32; ++i) {&#10;            buffer.push_back(i);&#10;        }&#10;        for (int i = 0; i &lt; 28; ++i) {&#10;            buffer.pop_front();&#10;        }&#10;        REQUIRE(buffer.size() == 4);&#10;        for (int i = 0; i &lt; 4; ++i) {&#10;            REQUIRE(buffer[i] == 28 + i);&#10;        }&#10;        REQUIRE(buffer.capacity() &lt;= 32);&#10;    }&#10;&#10;    SECTION(&quot;operator[] works after wraparound and resize&quot;) {&#10;        for (int i = 0; i &lt; 8; ++i) {&#10;            buffer.push_back(i);&#10;        }&#10;        for (int i = 0; i &lt; 4; ++i) {&#10;            buffer.pop_front();&#10;        }&#10;        for (int i = 8; i &lt; 12; ++i) {&#10;            buffer.push_back(i);&#10;        }&#10;        // Buffer now contains 4..11&#10;        for (int i = 0; i &lt; buffer.size(); ++i) {&#10;            REQUIRE(buffer[i] == 4 + i);&#10;        }&#10;    }&#10;}&#10;&#10;TEST_CASE(&quot;CircularBuffer robustness tests&quot;, &quot;[CircularBuffer][Robustness]&quot;) {&#10;    SECTION(&quot;Multiple upward resizes maintain correctness&quot;) {&#10;        CircularBuffer&lt;int&gt; buffer(8);&#10;&#10;        // Fill buffer to trigger multiple resizes&#10;        for (int i = 0; i &lt; 1000; ++i) {&#10;            buffer.push_back(i);&#10;        }&#10;&#10;        REQUIRE(buffer.size() == 1000);&#10;        REQUIRE(buffer.capacity() &gt;= 1000);&#10;&#10;        // Verify all elements are correct and accessible&#10;        for (int i = 0; i &lt; 1000; ++i) {&#10;            REQUIRE(buffer[i] == i);&#10;        }&#10;&#10;        // Verify front and back work correctly&#10;        REQUIRE(buffer.front() == 0);&#10;        REQUIRE(buffer.back() == 999);&#10;    }&#10;&#10;    SECTION(&quot;Multiple downward resizes maintain correctness&quot;) {&#10;        CircularBuffer&lt;int&gt; buffer(8);&#10;&#10;        // Fill buffer with many elements&#10;        for (int i = 0; i &lt; 1000; ++i) {&#10;            buffer.push_back(i);&#10;        }&#10;&#10;        // Remove most elements to trigger downward resizing&#10;        for (int i = 0; i &lt; 990; ++i) {&#10;            buffer.pop_front();&#10;        }&#10;&#10;        REQUIRE(buffer.size() == 10);&#10;        // Capacity should have decreased significantly&#10;        REQUIRE(buffer.capacity() &lt; 1000);&#10;&#10;        // Verify remaining elements are correct&#10;        for (int i = 0; i &lt; 10; ++i) {&#10;            REQUIRE(buffer[i] == 990 + i);&#10;        }&#10;&#10;        REQUIRE(buffer.front() == 990);&#10;        REQUIRE(buffer.back() == 999);&#10;    }&#10;&#10;    SECTION(&quot;Mixed operations with complex wraparound&quot;) {&#10;        CircularBuffer&lt;int&gt; buffer(16);&#10;&#10;        // Create complex pattern that causes wraparound&#10;        for (int cycle = 0; cycle &lt; 20; ++cycle) {&#10;            // Add elements&#10;            for (int i = 0; i &lt; 30; ++i) {&#10;                buffer.push_back(cycle * 100 + i);&#10;            }&#10;&#10;            // Remove some from front&#10;            for (int i = 0; i &lt; 15; ++i) {&#10;                buffer.pop_front();&#10;            }&#10;&#10;            // Add some to front&#10;            for (int i = 0; i &lt; 5; ++i) {&#10;                buffer.push_front(-(cycle * 100 + i + 1));&#10;            }&#10;&#10;            // Remove some from back&#10;            for (int i = 0; i &lt; 10; ++i) {&#10;                buffer.pop_back();&#10;            }&#10;        }&#10;&#10;        // Buffer should still be functional&#10;        REQUIRE(buffer.size() &gt; 0);&#10;&#10;        // operator[] should work for all valid indices&#10;        for (size_t i = 0; i &lt; buffer.size(); ++i) {&#10;            REQUIRE_NOTHROW(buffer[i]);&#10;        }&#10;&#10;        // front() and back() should work&#10;        REQUIRE_NOTHROW(buffer.front());&#10;        REQUIRE_NOTHROW(buffer.back());&#10;    }&#10;&#10;    SECTION(&quot;Size is maintained correctly through all operations&quot;) {&#10;        CircularBuffer&lt;int&gt; buffer(4);&#10;        size_t expected_size = 0;&#10;&#10;        // Push back operations&#10;        for (int i = 0; i &lt; 50; ++i) {&#10;            buffer.push_back(i);&#10;            ++expected_size;&#10;            REQUIRE(buffer.size() == expected_size);&#10;        }&#10;&#10;        // Push front operations&#10;        for (int i = 0; i &lt; 30; ++i) {&#10;            buffer.push_front(-i);&#10;            ++expected_size;&#10;            REQUIRE(buffer.size() == expected_size);&#10;        }&#10;&#10;        // Pop back operations&#10;        for (int i = 0; i &lt; 25; ++i) {&#10;            buffer.pop_back();&#10;            --expected_size;&#10;            REQUIRE(buffer.size() == expected_size);&#10;        }&#10;&#10;        // Pop front operations&#10;        for (int i = 0; i &lt; 25; ++i) {&#10;            buffer.pop_front();&#10;            --expected_size;&#10;            REQUIRE(buffer.size() == expected_size);&#10;        }&#10;&#10;        REQUIRE(expected_size == 30);&#10;        REQUIRE(buffer.size() == 30);&#10;    }&#10;&#10;    SECTION(&quot;operator[] correctness after resize operations&quot;) {&#10;        CircularBuffer&lt;int&gt; buffer(4);&#10;&#10;        // Fill with pattern&#10;        for (int i = 0; i &lt; 20; ++i) {&#10;            buffer.push_back(i * 3); // 0, 3, 6, 9, 12, ...&#10;        }&#10;&#10;        // Verify pattern after upward resize&#10;        for (int i = 0; i &lt; 20; ++i) {&#10;            REQUIRE(buffer[i] == i * 3);&#10;        }&#10;&#10;        // Remove elements from front to trigger potential downward resize&#10;        for (int i = 0; i &lt; 15; ++i) {&#10;            buffer.pop_front();&#10;        }&#10;&#10;        // Verify remaining elements are still correct&#10;        REQUIRE(buffer.size() == 5);&#10;        for (int i = 0; i &lt; 5; ++i) {&#10;            REQUIRE(buffer[i] == (15 + i) * 3); // Should be 45, 48, 51, 54, 57&#10;        }&#10;    }&#10;}&#10;&#10;TEST_CASE(&quot;CircularBuffer element construction/destruction count&quot;, &quot;[CircularBuffer][Lifetime]&quot;) {&#10;    TestingTracker::constructed = 0;&#10;    TestingTracker::destructed = 0;&#10;&#10;    constexpr int num_elements = 50; {&#10;        CircularBuffer&lt;TestingTracker&gt; buffer(8);&#10;        for (int i = 0; i &lt; num_elements; ++i) {&#10;            buffer.emplace_back();&#10;        }&#10;&#10;        REQUIRE(TestingTracker::constructed == num_elements);&#10;    }&#10;&#10;    REQUIRE(TestingTracker::destructed == num_elements);&#10;}&#10;&#10;TEST_CASE(&quot;CircularBuffer Iterator functionality&quot;, &quot;[CircularBuffer][Iterator]&quot;) {&#10;    SECTION(&quot;Basic iterator operations&quot;) {&#10;        CircularBuffer&lt;int&gt; buffer(4);&#10;        buffer.push_back(10);&#10;        buffer.push_back(20);&#10;        buffer.push_back(30);&#10;&#10;        auto it = buffer.begin();&#10;        REQUIRE(*it == 10);&#10;        ++it;&#10;        REQUIRE(*it == 20);&#10;        ++it;&#10;        REQUIRE(*it == 30);&#10;        ++it;&#10;        REQUIRE(it == buffer.end());&#10;    }&#10;&#10;    SECTION(&quot;Iterator dereference and modification&quot;) {&#10;        CircularBuffer&lt;int&gt; buffer(3);&#10;        buffer.push_back(1);&#10;        buffer.push_back(2);&#10;        buffer.push_back(3);&#10;&#10;        auto it = buffer.begin();&#10;        *it = 100;&#10;        REQUIRE(buffer[0] == 100);&#10;        REQUIRE(*it == 100);&#10;&#10;        ++it;&#10;        *it = 200;&#10;        REQUIRE(buffer[1] == 200);&#10;        REQUIRE(*it == 200);&#10;    }&#10;&#10;    SECTION(&quot;Range-based for loop&quot;) {&#10;        CircularBuffer&lt;int&gt; buffer(5);&#10;        for (int i = 1; i &lt;= 5; ++i) {&#10;            buffer.push_back(i * 10);&#10;        }&#10;&#10;        std::vector&lt;int&gt; collected;&#10;        for (const auto&amp; value : buffer) {&#10;            collected.push_back(value);&#10;        }&#10;&#10;        REQUIRE(collected.size() == 5);&#10;        for (size_t i = 0; i &lt; 5; ++i) {&#10;            REQUIRE(collected[i] == (i + 1) * 10);&#10;        }&#10;    }&#10;&#10;    SECTION(&quot;Range-based for loop with modification&quot;) {&#10;        CircularBuffer&lt;int&gt; buffer(3);&#10;        buffer.push_back(1);&#10;        buffer.push_back(2);&#10;        buffer.push_back(3);&#10;&#10;        for (auto&amp; value : buffer) {&#10;            value *= 2;&#10;        }&#10;&#10;        REQUIRE(buffer[0] == 2);&#10;        REQUIRE(buffer[1] == 4);&#10;        REQUIRE(buffer[2] == 6);&#10;    }&#10;&#10;    SECTION(&quot;Iterator with wraparound&quot;) {&#10;        CircularBuffer&lt;int&gt; buffer(4);&#10;        &#10;        // Fill buffer&#10;        for (int i = 0; i &lt; 4; ++i) {&#10;            buffer.push_back(i);&#10;        }&#10;        &#10;        // Remove from front and add to back to cause wraparound&#10;        buffer.pop_front(); // Remove 0&#10;        buffer.pop_front(); // Remove 1&#10;        buffer.push_back(4); // Add 4&#10;        buffer.push_back(5); // Add 5&#10;        &#10;        // Buffer now contains [2, 3, 4, 5] with wraparound&#10;        std::vector&lt;int&gt; expected = {2, 3, 4, 5};&#10;        std::vector&lt;int&gt; actual;&#10;        &#10;        for (const auto&amp; value : buffer) {&#10;            actual.push_back(value);&#10;        }&#10;        &#10;        REQUIRE(actual == expected);&#10;    }&#10;&#10;    SECTION(&quot;Empty buffer iteration&quot;) {&#10;        CircularBuffer&lt;int&gt; buffer(4);&#10;        &#10;        auto begin_it = buffer.begin();&#10;        auto end_it = buffer.end();&#10;        &#10;        REQUIRE(begin_it == end_it);&#10;        &#10;        // Range-based for loop should not execute&#10;        int count = 0;&#10;        for (const auto&amp; value : buffer) {&#10;            ++count;&#10;            (void)value; // Suppress unused variable warning&#10;        }&#10;        REQUIRE(count == 0);&#10;    }&#10;&#10;    SECTION(&quot;Single element iteration&quot;) {&#10;        CircularBuffer&lt;int&gt; buffer(4);&#10;        buffer.push_back(42);&#10;        &#10;        int count = 0;&#10;        for (const auto&amp; value : buffer) {&#10;            REQUIRE(value == 42);&#10;            ++count;&#10;        }&#10;        REQUIRE(count == 1);&#10;    }&#10;}&#10;&#10;TEST_CASE(&quot;CircularBuffer Iterator arithmetic operations&quot;, &quot;[CircularBuffer][Iterator]&quot;) {&#10;    SECTION(&quot;Iterator increment and decrement&quot;) {&#10;        CircularBuffer&lt;int&gt; buffer(5);&#10;        for (int i = 0; i &lt; 5; ++i) {&#10;            buffer.push_back(i * 10);&#10;        }&#10;&#10;        auto it = buffer.begin();&#10;        &#10;        // Test prefix increment&#10;        REQUIRE(*it == 0);&#10;        REQUIRE(*(++it) == 10);&#10;        REQUIRE(*it == 10);&#10;        &#10;        // Test postfix increment&#10;        REQUIRE(*(it++) == 10);&#10;        REQUIRE(*it == 20);&#10;        &#10;        // Test prefix decrement&#10;        REQUIRE(*(--it) == 10);&#10;        REQUIRE(*it == 10);&#10;        &#10;        // Test postfix decrement&#10;        REQUIRE(*(it--) == 10);&#10;        REQUIRE(*it == 0);&#10;    }&#10;&#10;    SECTION(&quot;Iterator addition and subtraction&quot;) {&#10;        CircularBuffer&lt;int&gt; buffer(5);&#10;        for (int i = 0; i &lt; 5; ++i) {&#10;            buffer.push_back(i * 10);&#10;        }&#10;&#10;        auto it = buffer.begin();&#10;        &#10;        // Test addition&#10;        auto it2 = it + 2;&#10;        REQUIRE(*it2 == 20);&#10;        &#10;        auto it3 = it + 4;&#10;        REQUIRE(*it3 == 40);&#10;        &#10;        // Test subtraction&#10;        auto it4 = it3 - 2;&#10;        REQUIRE(*it4 == 20);&#10;        &#10;        // Test compound assignment&#10;        it += 3;&#10;        REQUIRE(*it == 30);&#10;        &#10;        it -= 1;&#10;        REQUIRE(*it == 20);&#10;    }&#10;&#10;    SECTION(&quot;Iterator comparison operations&quot;) {&#10;        CircularBuffer&lt;int&gt; buffer(5);&#10;        for (int i = 0; i &lt; 5; ++i) {&#10;            buffer.push_back(i);&#10;        }&#10;&#10;        auto it1 = buffer.begin();&#10;        auto it2 = buffer.begin() + 2;&#10;        auto it3 = buffer.end();&#10;&#10;        REQUIRE(it1 &lt; it2);&#10;        REQUIRE(it2 &gt; it1);&#10;        REQUIRE(it1 &lt;= it2);&#10;        REQUIRE(it2 &gt;= it1);&#10;        REQUIRE(it1 != it2);&#10;        REQUIRE(it1 == buffer.begin());&#10;        &#10;        REQUIRE(it2 &lt; it3);&#10;        REQUIRE(it3 &gt; it2);&#10;    }&#10;&#10;    SECTION(&quot;Iterator distance&quot;) {&#10;        CircularBuffer&lt;int&gt; buffer(5);&#10;        for (int i = 0; i &lt; 5; ++i) {&#10;            buffer.push_back(i);&#10;        }&#10;&#10;        auto it1 = buffer.begin();&#10;        auto it2 = buffer.begin() + 3;&#10;        auto it3 = buffer.end();&#10;&#10;        REQUIRE(it2 - it1 == 3);&#10;        REQUIRE(it3 - it1 == 5);&#10;        REQUIRE(it3 - it2 == 2);&#10;    }&#10;}&#10;&#10;TEST_CASE(&quot;CircularBuffer Const Iterator functionality&quot;, &quot;[CircularBuffer][ConstIterator]&quot;) {&#10;    SECTION(&quot;Const iterator basic operations&quot;) {&#10;        CircularBuffer&lt;int&gt; buffer(3);&#10;        buffer.push_back(10);&#10;        buffer.push_back(20);&#10;        buffer.push_back(30);&#10;&#10;        const auto&amp; const_buffer = buffer;&#10;        &#10;        auto cit = const_buffer.begin();&#10;        REQUIRE(*cit == 10);&#10;        ++cit;&#10;        REQUIRE(*cit == 20);&#10;        ++cit;&#10;        REQUIRE(*cit == 30);&#10;        ++cit;&#10;        REQUIRE(cit == const_buffer.end());&#10;    }&#10;&#10;    SECTION(&quot;Const iterator range-based for loop&quot;) {&#10;        CircularBuffer&lt;std::string&gt; buffer(3);&#10;        buffer.push_back(&quot;hello&quot;);&#10;        buffer.push_back(&quot;world&quot;);&#10;        buffer.push_back(&quot;test&quot;);&#10;&#10;        const auto&amp; const_buffer = buffer;&#10;        &#10;        std::vector&lt;std::string&gt; collected;&#10;        for (const auto&amp; value : const_buffer) {&#10;            collected.push_back(value);&#10;        }&#10;&#10;        REQUIRE(collected.size() == 3);&#10;        REQUIRE(collected[0] == &quot;hello&quot;);&#10;        REQUIRE(collected[1] == &quot;world&quot;);&#10;        REQUIRE(collected[2] == &quot;test&quot;);&#10;    }&#10;&#10;    SECTION(&quot;cbegin and cend methods&quot;) {&#10;        CircularBuffer&lt;int&gt; buffer(3);&#10;        buffer.push_back(1);&#10;        buffer.push_back(2);&#10;        buffer.push_back(3);&#10;&#10;        auto cit = buffer.cbegin();&#10;        REQUIRE(*cit == 1);&#10;        ++cit;&#10;        REQUIRE(*cit == 2);&#10;        ++cit;&#10;        REQUIRE(*cit == 3);&#10;        ++cit;&#10;        REQUIRE(cit == buffer.cend());&#10;    }&#10;}&#10;&#10;TEST_CASE(&quot;CircularBuffer Iterator with complex operations&quot;, &quot;[CircularBuffer][Iterator]&quot;) {&#10;    SECTION(&quot;Iterator after buffer resize&quot;) {&#10;        CircularBuffer&lt;int&gt; buffer(4);&#10;        &#10;        // Fill buffer to capacity&#10;        for (int i = 0; i &lt; 4; ++i) {&#10;            buffer.push_back(i);&#10;        }&#10;        &#10;        // Add one more to trigger resize&#10;        buffer.push_back(4);&#10;        &#10;        // Verify iteration works after resize&#10;        std::vector&lt;int&gt; expected = {0, 1, 2, 3, 4};&#10;        std::vector&lt;int&gt; actual;&#10;        &#10;        for (const auto&amp; value : buffer) {&#10;            actual.push_back(value);&#10;        }&#10;        &#10;        REQUIRE(actual == expected);&#10;    }&#10;&#10;    SECTION(&quot;Iterator with pop operations&quot;) {&#10;        CircularBuffer&lt;int&gt; buffer(6);&#10;        &#10;        // Fill buffer&#10;        for (int i = 0; i &lt; 6; ++i) {&#10;            buffer.push_back(i * 10);&#10;        }&#10;        &#10;        // Remove some elements&#10;        buffer.pop_front(); // Remove 0&#10;        buffer.pop_back();  // Remove 50&#10;        &#10;        // Verify iteration works correctly&#10;        std::vector&lt;int&gt; expected = {10, 20, 30, 40};&#10;        std::vector&lt;int&gt; actual;&#10;        &#10;        for (const auto&amp; value : buffer) {&#10;            actual.push_back(value);&#10;        }&#10;        &#10;        REQUIRE(actual == expected);&#10;    }&#10;&#10;    SECTION(&quot;Iterator with mixed push/pop causing wraparound&quot;) {&#10;        CircularBuffer&lt;int&gt; buffer(4);&#10;        &#10;        // Fill buffer&#10;        for (int i = 0; i &lt; 4; ++i) {&#10;            buffer.push_back(i);&#10;        }&#10;        &#10;        // Create wraparound scenario&#10;        buffer.pop_front(); // Remove 0&#10;        buffer.pop_front(); // Remove 1  &#10;        buffer.push_back(4); // Add 4&#10;        buffer.push_back(5); // Add 5 (triggers resize)&#10;        &#10;        // Buffer should now contain [2, 3, 4, 5]&#10;        std::vector&lt;int&gt; expected = {2, 3, 4, 5};&#10;        std::vector&lt;int&gt; actual;&#10;        &#10;        for (const auto&amp; value : buffer) {&#10;            actual.push_back(value);&#10;        }&#10;        &#10;        REQUIRE(actual == expected);&#10;    }&#10;&#10;    SECTION(&quot;Iterator pointer access&quot;) {&#10;        struct TestStruct {&#10;            int value;&#10;            TestStruct(int v) : value(v) {}&#10;        };&#10;        &#10;        CircularBuffer&lt;TestStruct&gt; buffer(3);&#10;        buffer.emplace_back(10);&#10;        buffer.emplace_back(20);&#10;        buffer.emplace_back(30);&#10;        &#10;        auto it = buffer.begin();&#10;        REQUIRE(it-&gt;value == 10);&#10;        ++it;&#10;        REQUIRE(it-&gt;value == 20);&#10;        ++it;&#10;        REQUIRE(it-&gt;value == 30);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/test_deque.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/test_deque.cpp" />
              <option name="originalContent" value="#include &lt;catch2/catch_test_macros.hpp&gt;&#10;#include &quot;Deque.h&quot;&#10;#include &lt;string&gt;&#10;#include &lt;vector&gt;&#10;&#10;TEST_CASE(&quot;Deque construction&quot;, &quot;[Deque]&quot;) {&#10;    SECTION(&quot;Default construction&quot;) {&#10;        const Deque&lt;int&gt; deque;&#10;        REQUIRE(deque.size() == 0); // NOLINT&#10;    }&#10;}&#10;&#10;TEST_CASE(&quot;Deque push_back operations&quot;, &quot;[Deque]&quot;) {&#10;    Deque&lt;int&gt; deque;&#10;&#10;    SECTION(&quot;Push single element&quot;) {&#10;        deque.push_back(42);&#10;        REQUIRE(deque.size() == 1);&#10;        REQUIRE(deque[0] == 42);&#10;    }&#10;&#10;    SECTION(&quot;Push multiple elements&quot;) {&#10;        for (int i = 0; i &lt; 10; ++i) {&#10;            deque.push_back(i);&#10;        }&#10;        REQUIRE(deque.size() == 10);&#10;        for (int i = 0; i &lt; 10; ++i) {&#10;            REQUIRE(deque[i] == i);&#10;        }&#10;    }&#10;&#10;    SECTION(&quot;Push beyond single FixedArray capacity&quot;) {&#10;        // Push enough elements to trigger multiple FixedArrays&#10;        constexpr int num_elements = 5000; // More than fixed_arr_n_elem&#10;        for (int i = 0; i &lt; num_elements; ++i) {&#10;            deque.push_back(i);&#10;        }&#10;        REQUIRE(deque.size() == num_elements);&#10;        // Verify all elements are accessible and correct&#10;        for (int i = 0; i &lt; num_elements; ++i) {&#10;            REQUIRE(deque[i] == i);&#10;        }&#10;    }&#10;}&#10;&#10;TEST_CASE(&quot;Deque push_front operations&quot;, &quot;[Deque]&quot;) {&#10;    Deque&lt;int&gt; deque;&#10;&#10;    SECTION(&quot;Push single element to front&quot;) {&#10;        deque.push_front(42);&#10;        REQUIRE(deque.size() == 1);&#10;        REQUIRE(deque[0] == 42);&#10;    }&#10;&#10;    SECTION(&quot;Push multiple elements to front&quot;) {&#10;        for (int i = 0; i &lt; 10; ++i) {&#10;            deque.push_front(i);&#10;        }&#10;        REQUIRE(deque.size() == 10);&#10;        // Elements should be in reverse order&#10;        for (int i = 0; i &lt; 10; ++i) {&#10;            REQUIRE(deque[i] == 9 - i);&#10;        }&#10;    }&#10;&#10;    SECTION(&quot;Mix push_front and push_back&quot;) {&#10;        deque.push_back(1);&#10;        deque.push_back(2);&#10;        deque.push_front(0);&#10;        deque.push_front(-1);&#10;&#10;        REQUIRE(deque.size() == 4);&#10;        REQUIRE(deque[0] == -1);&#10;        REQUIRE(deque[1] == 0);&#10;        REQUIRE(deque[2] == 1);&#10;        REQUIRE(deque[3] == 2);&#10;    }&#10;}&#10;&#10;TEST_CASE(&quot;Deque pop operations&quot;, &quot;[Deque]&quot;) {&#10;    Deque&lt;int&gt; deque;&#10;&#10;    SECTION(&quot;Pop from back&quot;) {&#10;        deque.push_back(1);&#10;        deque.push_back(2);&#10;        deque.push_back(3);&#10;&#10;        REQUIRE(deque.pop_back() == 3);&#10;        REQUIRE(deque.size() == 2);&#10;        REQUIRE(deque.pop_back() == 2);&#10;        REQUIRE(deque.size() == 1);&#10;        REQUIRE(deque.pop_back() == 1);&#10;        REQUIRE(deque.size() == 0); // NOLINT&#10;    }&#10;&#10;    SECTION(&quot;Pop from front&quot;) {&#10;        deque.push_back(1);&#10;        deque.push_back(2);&#10;        deque.push_back(3);&#10;&#10;        REQUIRE(deque.pop_front() == 1);&#10;        REQUIRE(deque.size() == 2);&#10;        REQUIRE(deque.pop_front() == 2);&#10;        REQUIRE(deque.size() == 1);&#10;        REQUIRE(deque.pop_front() == 3);&#10;        REQUIRE(deque.size() == 0); // NOLINT&#10;    }&#10;&#10;    SECTION(&quot;Mix pop operations&quot;) {&#10;        for (int i = 0; i &lt; 10; ++i) {&#10;            deque.push_back(i);&#10;        }&#10;&#10;        REQUIRE(deque.pop_front() == 0);&#10;        REQUIRE(deque.pop_back() == 9);&#10;        REQUIRE(deque.pop_front() == 1);&#10;        REQUIRE(deque.pop_back() == 8);&#10;&#10;        REQUIRE(deque.size() == 6);&#10;        REQUIRE(deque[0] == 2);&#10;        REQUIRE(deque[5] == 7);&#10;    }&#10;}&#10;&#10;TEST_CASE(&quot;Deque operator[] access&quot;, &quot;[Deque]&quot;) {&#10;    Deque&lt;int&gt; deque;&#10;&#10;    SECTION(&quot;Random access after mixed operations&quot;) {&#10;        // Fill deque with pattern&#10;        for (int i = 0; i &lt; 100; ++i) {&#10;            if (i % 2 == 0) {&#10;                deque.push_back(i);&#10;            } else {&#10;                deque.push_front(-i);&#10;            }&#10;        }&#10;&#10;        // Verify all elements are accessible&#10;        for (size_t i = 0; i &lt; deque.size(); ++i) { // NOLINT&#10;            // This should not throw and should return a valid value&#10;            REQUIRE_NOTHROW(deque[i]);&#10;        }&#10;    }&#10;&#10;    SECTION(&quot;Access across multiple FixedArrays&quot;) {&#10;        constexpr int num_elements = 10000;&#10;        for (int i = 0; i &lt; num_elements; ++i) {&#10;            deque.push_back(i * 2); // Use a pattern to verify correctness&#10;        }&#10;&#10;        // Test random access across the entire range&#10;        for (int i = 0; i &lt; num_elements; ++i) {&#10;            REQUIRE(deque[i] == i * 2);&#10;        }&#10;&#10;        // Test access at boundaries&#10;        REQUIRE(deque[0] == 0);&#10;        REQUIRE(deque[num_elements - 1] == (num_elements - 1) * 2);&#10;    }&#10;}&#10;&#10;TEST_CASE(&quot;Deque with strings&quot;, &quot;[Deque]&quot;) {&#10;    SECTION(&quot;String operations&quot;) {&#10;        Deque&lt;std::string&gt; deque;&#10;        deque.push_back(std::string(&quot;hello&quot;));&#10;        deque.push_back(&quot;world&quot;);&#10;        deque.push_front(&quot;hi&quot;);&#10;&#10;        REQUIRE(deque.size() == 3);&#10;        REQUIRE(deque[0] == &quot;hi&quot;);&#10;        REQUIRE(deque[1] == &quot;hello&quot;);&#10;        REQUIRE(deque[2] == &quot;world&quot;);&#10;&#10;        REQUIRE(deque.pop_back() == &quot;world&quot;);&#10;        REQUIRE(deque.pop_front() == &quot;hi&quot;);&#10;        REQUIRE(deque[0] == &quot;hello&quot;);&#10;    }&#10;}&#10;&#10;TEST_CASE(&quot;Deque stress test&quot;, &quot;[Deque][Stress]&quot;) {&#10;    Deque&lt;int&gt; deque;&#10;&#10;    SECTION(&quot;Large scale operations&quot;) {&#10;        constexpr int operations = 50000;&#10;&#10;        // Add many elements&#10;        for (int i = 0; i &lt; operations; ++i) {&#10;            deque.push_back(i);&#10;        }&#10;        REQUIRE(deque.size() == operations);&#10;&#10;        // Remove half from front&#10;        for (int i = 0; i &lt; operations / 2; ++i) {&#10;            REQUIRE(deque.pop_front() == i);&#10;        }&#10;        REQUIRE(deque.size() == operations / 2);&#10;&#10;        // Add more to front&#10;        for (int i = 0; i &lt; operations / 4; ++i) {&#10;            deque.push_front(-i - 1);&#10;        }&#10;&#10;        // Verify size and some elements&#10;        REQUIRE(deque.size() == operations / 2 + operations / 4);&#10;        REQUIRE(deque[0] == -operations / 4);&#10;        REQUIRE(deque[operations / 4] == operations / 2);&#10;    }&#10;&#10;    SECTION(&quot;Alternating push/pop pattern&quot;) {&#10;        // This tests the dynamic resizing behavior&#10;        for (int cycle = 0; cycle &lt; 1000; ++cycle) {&#10;            // Push a bunch&#10;            for (int i = 0; i &lt; 100; ++i) {&#10;                deque.push_back(cycle * 100 + i);&#10;            }&#10;&#10;            // Pop some&#10;            for (int i = 0; i &lt; 50; ++i) {&#10;                deque.pop_front();&#10;            }&#10;        }&#10;&#10;        // Should still be functional&#10;        REQUIRE(deque.size() == 50000); // 1000 * (100 - 50)&#10;&#10;        // Test random access still works&#10;        for (size_t i = 0; i &lt; std::min(deque.size(), 100zu); ++i) {&#10;            REQUIRE_NOTHROW(deque[i]);&#10;        }&#10;    }&#10;}&#10;&#10;TEST_CASE(&quot;Deque Constructors&quot;, &quot;[Deque]&quot;) {&#10;    SECTION(&quot;Initializer list construction&quot;) {&#10;        const Deque deque = {1, 2, 3, 4, 5};&#10;        REQUIRE(deque.size() == 5);&#10;        REQUIRE(deque[0] == 1);&#10;        REQUIRE(deque[1] == 2);&#10;        REQUIRE(deque[2] == 3);&#10;        REQUIRE(deque[3] == 4);&#10;        REQUIRE(deque[4] == 5);&#10;        REQUIRE(deque.front() == 1);&#10;        REQUIRE(deque.back() == 5);&#10;    }&#10;&#10;    SECTION(&quot;Initializer list with strings&quot;) {&#10;        Deque&lt;std::string&gt; deque = {&quot;one&quot;, &quot;two&quot;, &quot;three&quot;};&#10;        REQUIRE(deque.size() == 3);&#10;        REQUIRE(deque[0] == &quot;one&quot;);&#10;        REQUIRE(deque[1] == &quot;two&quot;);&#10;        REQUIRE(deque[2] == &quot;three&quot;);&#10;    }&#10;}&#10;&#10;TEST_CASE(&quot;Deque Iterator operations&quot;, &quot;[Deque][Iterator]&quot;) {&#10;    SECTION(&quot;Basic iterator functionality&quot;) {&#10;        Deque deque = {1, 2, 3, 4, 5};&#10;&#10;        // Test begin() and end()&#10;        auto it = deque.begin();&#10;        auto end_it = deque.end();&#10;&#10;        REQUIRE(*it == 1);&#10;&#10;        // Test dereference operator&#10;        REQUIRE(*it == 1);&#10;        *it = 10;&#10;        REQUIRE(*it == 10);&#10;        REQUIRE(deque[0] == 10);&#10;        REQUIRE(*(end_it.prev()) == 5); // Should point to last element&#10;    }&#10;&#10;    SECTION(&quot;Iterator increment operations&quot;) {&#10;        Deque deque = {1, 2, 3, 4, 5};&#10;        auto it = deque.begin();&#10;&#10;        // Test prefix increment&#10;        REQUIRE(*it == 1);&#10;        ++it;&#10;        REQUIRE(*it == 2);&#10;        ++it;&#10;        REQUIRE(*it == 3);&#10;&#10;        // Test postfix increment&#10;        auto old_it = it++;&#10;        REQUIRE(*old_it == 3);&#10;        REQUIRE(*it == 4);&#10;    }&#10;&#10;    SECTION(&quot;Iterator decrement operations&quot;) {&#10;        Deque deque = {1, 2, 3, 4, 5};&#10;        auto it = deque.begin();&#10;&#10;        // Move to middle&#10;        ++it;&#10;        ++it;&#10;        REQUIRE(*it == 3);&#10;&#10;        // Test prefix decrement&#10;        --it;&#10;        REQUIRE(*it == 2);&#10;        --it;&#10;        REQUIRE(*it == 1);&#10;&#10;        // Test postfix decrement&#10;        ++it;&#10;        ++it;&#10;        REQUIRE(*it == 3);&#10;        auto old_it = it--;&#10;        REQUIRE(*old_it == 3);&#10;        REQUIRE(*it == 2);&#10;    }&#10;&#10;    SECTION(&quot;Iterator traversal&quot;) {&#10;        Deque&lt;int&gt; deque;&#10;        for (int i = 0; i &lt; 10; ++i) {&#10;            deque.push_back(i);&#10;        }&#10;&#10;        // Forward traversal&#10;        int expected = 0;&#10;        for (auto it = deque.begin(); it.current_array != nullptr; ++it) {&#10;            REQUIRE(*it == expected);&#10;            ++expected;&#10;        }&#10;        REQUIRE(expected == 10);&#10;&#10;        // Manual traversal using next()&#10;        auto it = deque.begin();&#10;        for (int i = 0; i &lt; 10; ++i) {&#10;            REQUIRE(*it == i);&#10;            it = it.next();&#10;        }&#10;        REQUIRE(it.current_array == nullptr); // Should be at end&#10;    }&#10;&#10;    SECTION(&quot;Iterator with large deque across multiple FixedArrays&quot;) {&#10;        Deque&lt;int&gt; deque;&#10;        constexpr int num_elements = 10000; // Ensure multiple FixedArrays&#10;&#10;        for (int i = 0; i &lt; num_elements; ++i) {&#10;            deque.push_back(i);&#10;        }&#10;&#10;        // Test forward iteration through all elements&#10;        int count = 0;&#10;        for (auto it = deque.begin(); it.current_array != nullptr; ++it) {&#10;            REQUIRE(*it == count);&#10;            ++count;&#10;        }&#10;        REQUIRE(count == num_elements);&#10;&#10;        // Test that we can modify elements through iterator&#10;        auto it = deque.begin();&#10;        for (int i = 0; i &lt; 100; ++i) {&#10;            *it = i * 10;&#10;            ++it;&#10;        }&#10;&#10;        // Verify modifications&#10;        for (int i = 0; i &lt; 100; ++i) {&#10;            REQUIRE(deque[i] == i * 10);&#10;        }&#10;    }&#10;&#10;    SECTION(&quot;Iterator with mixed push operations&quot;) {&#10;        Deque&lt;int&gt; deque;&#10;&#10;        // Create a pattern: push_front some, push_back some&#10;        for (int i = 0; i &lt; 5; ++i) {&#10;            deque.push_front(-i - 1); // -1, -2, -3, -4, -5&#10;            deque.push_back(i + 1); //  1,  2,  3,  4,  5&#10;        }&#10;&#10;        // Expected order: [-5, -4, -3, -2, -1, 1, 2, 3, 4, 5]&#10;        std::vector expected = {-5, -4, -3, -2, -1, 1, 2, 3, 4, 5};&#10;&#10;        int index = 0;&#10;        for (auto it = deque.begin(); it.current_array != nullptr; ++it) {&#10;            REQUIRE(*it == expected[index]);&#10;            ++index;&#10;        }&#10;        REQUIRE(index == expected.size());&#10;    }&#10;&#10;    SECTION(&quot;Range-based for loop&quot;) {&#10;        Deque&lt;std::string&gt; deque = {&quot;hello&quot;, &quot;world&quot;, &quot;test&quot;};&#10;&#10;        std::vector&lt;std::string&gt; collected;&#10;        for (const auto &amp;item: deque) {&#10;            collected.push_back(item);&#10;        }&#10;&#10;        REQUIRE(collected.size() == 3);&#10;        REQUIRE(collected[0] == &quot;hello&quot;);&#10;        REQUIRE(collected[1] == &quot;world&quot;);&#10;        REQUIRE(collected[2] == &quot;test&quot;);&#10;    }&#10;&#10;    SECTION(&quot;Empty deque iterator&quot;) {&#10;        Deque&lt;int&gt; deque;&#10;&#10;        auto begin_it = deque.begin();&#10;        auto end_it = deque.end();&#10;&#10;        // For empty deque, begin should point to end immediately&#10;        REQUIRE(begin_it.current_array == nullptr); // Points to the initial FixedArray&#10;        REQUIRE(end_it.current_array == nullptr);&#10;        ++begin_it;&#10;        REQUIRE(begin_it.current_array == nullptr);&#10;    }&#10;&#10;    SECTION(&quot;Iterator prev() method&quot;) {&#10;        Deque deque = {1, 2, 3, 4, 5};&#10;&#10;        // Start from end and work backwards using prev()&#10;        auto it = deque.end().prev();&#10;        REQUIRE(*it == 5);&#10;&#10;        it = it.prev();&#10;        REQUIRE(*it == 4);&#10;&#10;        it = it.prev();&#10;        REQUIRE(*it == 3);&#10;&#10;        it = it.prev();&#10;        REQUIRE(*it == 2);&#10;&#10;        it = it.prev();&#10;        REQUIRE(*it == 1);&#10;    }&#10;&#10;    SECTION(&quot;Iterator boundary conditions&quot;) {&#10;        Deque&lt;int&gt; deque;&#10;&#10;        // Test with exactly one element&#10;        deque.push_back(42);&#10;        auto it = deque.begin();&#10;        REQUIRE(*it == 42);&#10;&#10;        ++it;&#10;        REQUIRE(it.current_array == nullptr); // Should be at end&#10;&#10;        // Test prev from end&#10;        it = deque.end().prev();&#10;        REQUIRE(*it == 42);&#10;    }&#10;}&#10;&#10;class Tracker {&#10;public:&#10;    static int constructed;&#10;    static int destructed;&#10;&#10;    Tracker() {&#10;        constructed++;&#10;    }&#10;&#10;    Tracker(const Tracker &amp;) {&#10;        constructed++;&#10;    }&#10;&#10;    ~Tracker() {&#10;        destructed++;&#10;    }&#10;};&#10;int Tracker::constructed = 0;&#10;int Tracker::destructed = 0;&#10;&#10;&#10;TEST_CASE(&quot;Deque element construction/destruction count&quot;, &quot;[Deque][Lifetime]&quot;) {&#10;    Tracker::constructed = 0;&#10;    Tracker::destructed = 0;&#10;&#10;    constexpr int num_elements = 100; {&#10;        Deque&lt;Tracker&gt; deque;&#10;        for (int i = 0; i &lt; num_elements; ++i) {&#10;            deque.emplace_back();&#10;        }&#10;        REQUIRE(Tracker::constructed == num_elements);&#10;        REQUIRE(deque.size() == num_elements);&#10;    } // Deque goes out of scope, all elements should be destructed&#10;    REQUIRE(Tracker::destructed == num_elements);&#10;}&#10;" />
              <option name="updatedContent" value="#include &lt;catch2/catch_test_macros.hpp&gt;&#10;#include &quot;Deque.h&quot;&#10;#include &lt;string&gt;&#10;#include &lt;vector&gt;&#10;&#10;TEST_CASE(&quot;Deque construction&quot;, &quot;[Deque]&quot;) {&#10;    SECTION(&quot;Default construction&quot;) {&#10;        const Deque&lt;int&gt; deque;&#10;        REQUIRE(deque.size() == 0); // NOLINT&#10;    }&#10;}&#10;&#10;TEST_CASE(&quot;Deque push_back operations&quot;, &quot;[Deque]&quot;) {&#10;    Deque&lt;int&gt; deque;&#10;&#10;    SECTION(&quot;Push single element&quot;) {&#10;        deque.push_back(42);&#10;        REQUIRE(deque.size() == 1);&#10;        REQUIRE(deque[0] == 42);&#10;    }&#10;&#10;    SECTION(&quot;Push multiple elements&quot;) {&#10;        for (int i = 0; i &lt; 10; ++i) {&#10;            deque.push_back(i);&#10;        }&#10;        REQUIRE(deque.size() == 10);&#10;        for (int i = 0; i &lt; 10; ++i) {&#10;            REQUIRE(deque[i] == i);&#10;        }&#10;    }&#10;&#10;    SECTION(&quot;Push beyond single FixedArray capacity&quot;) {&#10;        // Push enough elements to trigger multiple FixedArrays&#10;        constexpr int num_elements = 5000; // More than fixed_arr_n_elem&#10;        for (int i = 0; i &lt; num_elements; ++i) {&#10;            deque.push_back(i);&#10;        }&#10;        REQUIRE(deque.size() == num_elements);&#10;        // Verify all elements are accessible and correct&#10;        for (int i = 0; i &lt; num_elements; ++i) {&#10;            REQUIRE(deque[i] == i);&#10;        }&#10;    }&#10;}&#10;&#10;TEST_CASE(&quot;Deque push_front operations&quot;, &quot;[Deque]&quot;) {&#10;    Deque&lt;int&gt; deque;&#10;&#10;    SECTION(&quot;Push single element to front&quot;) {&#10;        deque.push_front(42);&#10;        REQUIRE(deque.size() == 1);&#10;        REQUIRE(deque[0] == 42);&#10;    }&#10;&#10;    SECTION(&quot;Push multiple elements to front&quot;) {&#10;        for (int i = 0; i &lt; 10; ++i) {&#10;            deque.push_front(i);&#10;        }&#10;        REQUIRE(deque.size() == 10);&#10;        // Elements should be in reverse order&#10;        for (int i = 0; i &lt; 10; ++i) {&#10;            REQUIRE(deque[i] == 9 - i);&#10;        }&#10;    }&#10;&#10;    SECTION(&quot;Mix push_front and push_back&quot;) {&#10;        deque.push_back(1);&#10;        deque.push_back(2);&#10;        deque.push_front(0);&#10;        deque.push_front(-1);&#10;&#10;        REQUIRE(deque.size() == 4);&#10;        REQUIRE(deque[0] == -1);&#10;        REQUIRE(deque[1] == 0);&#10;        REQUIRE(deque[2] == 1);&#10;        REQUIRE(deque[3] == 2);&#10;    }&#10;}&#10;&#10;TEST_CASE(&quot;Deque pop operations&quot;, &quot;[Deque]&quot;) {&#10;    Deque&lt;int&gt; deque;&#10;&#10;    SECTION(&quot;Pop from back&quot;) {&#10;        deque.push_back(1);&#10;        deque.push_back(2);&#10;        deque.push_back(3);&#10;&#10;        REQUIRE(deque.pop_back() == 3);&#10;        REQUIRE(deque.size() == 2);&#10;        REQUIRE(deque.pop_back() == 2);&#10;        REQUIRE(deque.size() == 1);&#10;        REQUIRE(deque.pop_back() == 1);&#10;        REQUIRE(deque.size() == 0); // NOLINT&#10;    }&#10;&#10;    SECTION(&quot;Pop from front&quot;) {&#10;        deque.push_back(1);&#10;        deque.push_back(2);&#10;        deque.push_back(3);&#10;&#10;        REQUIRE(deque.pop_front() == 1);&#10;        REQUIRE(deque.size() == 2);&#10;        REQUIRE(deque.pop_front() == 2);&#10;        REQUIRE(deque.size() == 1);&#10;        REQUIRE(deque.pop_front() == 3);&#10;        REQUIRE(deque.size() == 0); // NOLINT&#10;    }&#10;&#10;    SECTION(&quot;Mix pop operations&quot;) {&#10;        for (int i = 0; i &lt; 10; ++i) {&#10;            deque.push_back(i);&#10;        }&#10;&#10;        REQUIRE(deque.pop_front() == 0);&#10;        REQUIRE(deque.pop_back() == 9);&#10;        REQUIRE(deque.pop_front() == 1);&#10;        REQUIRE(deque.pop_back() == 8);&#10;&#10;        REQUIRE(deque.size() == 6);&#10;        REQUIRE(deque[0] == 2);&#10;        REQUIRE(deque[5] == 7);&#10;    }&#10;}&#10;&#10;TEST_CASE(&quot;Deque operator[] access&quot;, &quot;[Deque]&quot;) {&#10;    Deque&lt;int&gt; deque;&#10;&#10;    SECTION(&quot;Random access after mixed operations&quot;) {&#10;        // Fill deque with pattern&#10;        for (int i = 0; i &lt; 100; ++i) {&#10;            if (i % 2 == 0) {&#10;                deque.push_back(i);&#10;            } else {&#10;                deque.push_front(-i);&#10;            }&#10;        }&#10;&#10;        // Verify all elements are accessible&#10;        for (size_t i = 0; i &lt; deque.size(); ++i) { // NOLINT&#10;            // This should not throw and should return a valid value&#10;            REQUIRE_NOTHROW(deque[i]);&#10;        }&#10;    }&#10;&#10;    SECTION(&quot;Access across multiple FixedArrays&quot;) {&#10;        constexpr int num_elements = 10000;&#10;        for (int i = 0; i &lt; num_elements; ++i) {&#10;            deque.push_back(i * 2); // Use a pattern to verify correctness&#10;        }&#10;&#10;        // Test random access across the entire range&#10;        for (int i = 0; i &lt; num_elements; ++i) {&#10;            REQUIRE(deque[i] == i * 2);&#10;        }&#10;&#10;        // Test access at boundaries&#10;        REQUIRE(deque[0] == 0);&#10;        REQUIRE(deque[num_elements - 1] == (num_elements - 1) * 2);&#10;    }&#10;}&#10;&#10;TEST_CASE(&quot;Deque with strings&quot;, &quot;[Deque]&quot;) {&#10;    SECTION(&quot;String operations&quot;) {&#10;        Deque&lt;std::string&gt; deque;&#10;        deque.push_back(std::string(&quot;hello&quot;));&#10;        deque.push_back(&quot;world&quot;);&#10;        deque.push_front(&quot;hi&quot;);&#10;&#10;        REQUIRE(deque.size() == 3);&#10;        REQUIRE(deque[0] == &quot;hi&quot;);&#10;        REQUIRE(deque[1] == &quot;hello&quot;);&#10;        REQUIRE(deque[2] == &quot;world&quot;);&#10;&#10;        REQUIRE(deque.pop_back() == &quot;world&quot;);&#10;        REQUIRE(deque.pop_front() == &quot;hi&quot;);&#10;        REQUIRE(deque[0] == &quot;hello&quot;);&#10;    }&#10;}&#10;&#10;TEST_CASE(&quot;Deque stress test&quot;, &quot;[Deque][Stress]&quot;) {&#10;    Deque&lt;int&gt; deque;&#10;&#10;    SECTION(&quot;Large scale operations&quot;) {&#10;        constexpr int operations = 50000;&#10;&#10;        // Add many elements&#10;        for (int i = 0; i &lt; operations; ++i) {&#10;            deque.push_back(i);&#10;        }&#10;        REQUIRE(deque.size() == operations);&#10;&#10;        // Remove half from front&#10;        for (int i = 0; i &lt; operations / 2; ++i) {&#10;            REQUIRE(deque.pop_front() == i);&#10;        }&#10;        REQUIRE(deque.size() == operations / 2);&#10;&#10;        // Add more to front&#10;        for (int i = 0; i &lt; operations / 4; ++i) {&#10;            deque.push_front(-i - 1);&#10;        }&#10;&#10;        // Verify size and some elements&#10;        REQUIRE(deque.size() == operations / 2 + operations / 4);&#10;        REQUIRE(deque[0] == -operations / 4);&#10;        REQUIRE(deque[operations / 4] == operations / 2);&#10;    }&#10;&#10;    SECTION(&quot;Alternating push/pop pattern&quot;) {&#10;        // This tests the dynamic resizing behavior&#10;        for (int cycle = 0; cycle &lt; 1000; ++cycle) {&#10;            // Push a bunch&#10;            for (int i = 0; i &lt; 100; ++i) {&#10;                deque.push_back(cycle * 100 + i);&#10;            }&#10;&#10;            // Pop some&#10;            for (int i = 0; i &lt; 50; ++i) {&#10;                deque.pop_front();&#10;            }&#10;        }&#10;&#10;        // Should still be functional&#10;        REQUIRE(deque.size() == 50000); // 1000 * (100 - 50)&#10;&#10;        // Test random access still works&#10;        for (size_t i = 0; i &lt; std::min(deque.size(), 100zu); ++i) {&#10;            REQUIRE_NOTHROW(deque[i]);&#10;        }&#10;    }&#10;}&#10;&#10;TEST_CASE(&quot;Deque Constructors&quot;, &quot;[Deque]&quot;) {&#10;    SECTION(&quot;Initializer list construction&quot;) {&#10;        const Deque deque = {1, 2, 3, 4, 5};&#10;        REQUIRE(deque.size() == 5);&#10;        REQUIRE(deque[0] == 1);&#10;        REQUIRE(deque[1] == 2);&#10;        REQUIRE(deque[2] == 3);&#10;        REQUIRE(deque[3] == 4);&#10;        REQUIRE(deque[4] == 5);&#10;        REQUIRE(deque.front() == 1);&#10;        REQUIRE(deque.back() == 5);&#10;    }&#10;&#10;    SECTION(&quot;Initializer list with strings&quot;) {&#10;        Deque&lt;std::string&gt; deque = {&quot;one&quot;, &quot;two&quot;, &quot;three&quot;};&#10;        REQUIRE(deque.size() == 3);&#10;        REQUIRE(deque[0] == &quot;one&quot;);&#10;        REQUIRE(deque[1] == &quot;two&quot;);&#10;        REQUIRE(deque[2] == &quot;three&quot;);&#10;    }&#10;}&#10;&#10;TEST_CASE(&quot;Deque Iterator operations&quot;, &quot;[Deque][Iterator]&quot;) {&#10;    SECTION(&quot;Basic iterator functionality&quot;) {&#10;        Deque deque = {1, 2, 3, 4, 5};&#10;&#10;        // Test begin() and end()&#10;        auto it = deque.begin();&#10;        auto end_it = deque.end();&#10;&#10;        REQUIRE(*it == 1);&#10;&#10;        // Test dereference operator&#10;        REQUIRE(*it == 1);&#10;        *it = 10;&#10;        REQUIRE(*it == 10);&#10;        REQUIRE(deque[0] == 10);&#10;        REQUIRE(*(end_it.prev()) == 5); // Should point to last element&#10;    }&#10;&#10;    SECTION(&quot;Iterator increment operations&quot;) {&#10;        Deque deque = {1, 2, 3, 4, 5};&#10;        auto it = deque.begin();&#10;&#10;        // Test prefix increment&#10;        REQUIRE(*it == 1);&#10;        ++it;&#10;        REQUIRE(*it == 2);&#10;        ++it;&#10;        REQUIRE(*it == 3);&#10;&#10;        // Test postfix increment&#10;        auto old_it = it++;&#10;        REQUIRE(*old_it == 3);&#10;        REQUIRE(*it == 4);&#10;    }&#10;&#10;    SECTION(&quot;Iterator decrement operations&quot;) {&#10;        Deque deque = {1, 2, 3, 4, 5};&#10;        auto it = deque.begin();&#10;&#10;        // Move to middle&#10;        ++it;&#10;        ++it;&#10;        REQUIRE(*it == 3);&#10;&#10;        // Test prefix decrement&#10;        --it;&#10;        REQUIRE(*it == 2);&#10;        --it;&#10;        REQUIRE(*it == 1);&#10;&#10;        // Test postfix decrement&#10;        ++it;&#10;        ++it;&#10;        REQUIRE(*it == 3);&#10;        auto old_it = it--;&#10;        REQUIRE(*old_it == 3);&#10;        REQUIRE(*it == 2);&#10;    }&#10;&#10;    SECTION(&quot;Iterator traversal&quot;) {&#10;        Deque&lt;int&gt; deque;&#10;        for (int i = 0; i &lt; 10; ++i) {&#10;            deque.push_back(i);&#10;        }&#10;&#10;        // Forward traversal&#10;        int expected = 0;&#10;        for (auto it = deque.begin(); it.current_array != nullptr; ++it) {&#10;            REQUIRE(*it == expected);&#10;            ++expected;&#10;        }&#10;        REQUIRE(expected == 10);&#10;&#10;        // Manual traversal using next()&#10;        auto it = deque.begin();&#10;        for (int i = 0; i &lt; 10; ++i) {&#10;            REQUIRE(*it == i);&#10;            it = it.next();&#10;        }&#10;        REQUIRE(it.current_array == nullptr); // Should be at end&#10;    }&#10;&#10;    SECTION(&quot;Iterator with large deque across multiple FixedArrays&quot;) {&#10;        Deque&lt;int&gt; deque;&#10;        constexpr int num_elements = 10000; // Ensure multiple FixedArrays&#10;&#10;        for (int i = 0; i &lt; num_elements; ++i) {&#10;            deque.push_back(i);&#10;        }&#10;&#10;        // Test forward iteration through all elements&#10;        int count = 0;&#10;        for (auto it = deque.begin(); it.current_array != nullptr; ++it) {&#10;            REQUIRE(*it == count);&#10;            ++count;&#10;        }&#10;        REQUIRE(count == num_elements);&#10;&#10;        // Test that we can modify elements through iterator&#10;        auto it = deque.begin();&#10;        for (int i = 0; i &lt; 100; ++i) {&#10;            *it = i * 10;&#10;            ++it;&#10;        }&#10;&#10;        // Verify modifications&#10;        for (int i = 0; i &lt; 100; ++i) {&#10;            REQUIRE(deque[i] == i * 10);&#10;        }&#10;    }&#10;&#10;    SECTION(&quot;Iterator with mixed push operations&quot;) {&#10;        Deque&lt;int&gt; deque;&#10;&#10;        // Create a pattern: push_front some, push_back some&#10;        for (int i = 0; i &lt; 5; ++i) {&#10;            deque.push_front(-i - 1); // -1, -2, -3, -4, -5&#10;            deque.push_back(i + 1); //  1,  2,  3,  4,  5&#10;        }&#10;&#10;        // Expected order: [-5, -4, -3, -2, -1, 1, 2, 3, 4, 5]&#10;        std::vector expected = {-5, -4, -3, -2, -1, 1, 2, 3, 4, 5};&#10;&#10;        int index = 0;&#10;        for (auto it = deque.begin(); it.current_array != nullptr; ++it) {&#10;            REQUIRE(*it == expected[index]);&#10;            ++index;&#10;        }&#10;        REQUIRE(index == expected.size());&#10;    }&#10;&#10;    SECTION(&quot;Range-based for loop&quot;) {&#10;        Deque&lt;std::string&gt; deque = {&quot;hello&quot;, &quot;world&quot;, &quot;test&quot;};&#10;&#10;        std::vector&lt;std::string&gt; collected;&#10;        for (const auto &amp;item: deque) {&#10;            collected.push_back(item);&#10;        }&#10;&#10;        REQUIRE(collected.size() == 3);&#10;        REQUIRE(collected[0] == &quot;hello&quot;);&#10;        REQUIRE(collected[1] == &quot;world&quot;);&#10;        REQUIRE(collected[2] == &quot;test&quot;);&#10;    }&#10;&#10;    SECTION(&quot;Empty deque iterator&quot;) {&#10;        Deque&lt;int&gt; deque;&#10;&#10;        auto begin_it = deque.begin();&#10;        auto end_it = deque.end();&#10;&#10;        // For empty deque, begin should point to end immediately&#10;        REQUIRE(begin_it.current_array == nullptr); // Points to the initial FixedArray&#10;        REQUIRE(end_it.current_array == nullptr);&#10;        ++begin_it;&#10;        REQUIRE(begin_it.current_array == nullptr);&#10;    }&#10;&#10;    SECTION(&quot;Iterator prev() method&quot;) {&#10;        Deque deque = {1, 2, 3, 4, 5};&#10;&#10;        // Start from end and work backwards using prev()&#10;        auto it = deque.end().prev();&#10;        REQUIRE(*it == 5);&#10;&#10;        it = it.prev();&#10;        REQUIRE(*it == 4);&#10;&#10;        it = it.prev();&#10;        REQUIRE(*it == 3);&#10;&#10;        it = it.prev();&#10;        REQUIRE(*it == 2);&#10;&#10;        it = it.prev();&#10;        REQUIRE(*it == 1);&#10;    }&#10;&#10;    SECTION(&quot;Iterator boundary conditions&quot;) {&#10;        Deque&lt;int&gt; deque;&#10;&#10;        // Test with exactly one element&#10;        deque.push_back(42);&#10;        auto it = deque.begin();&#10;        REQUIRE(*it == 42);&#10;&#10;        ++it;&#10;        REQUIRE(it.current_array == nullptr); // Should be at end&#10;&#10;        // Test prev from end&#10;        it = deque.end().prev();&#10;        REQUIRE(*it == 42);&#10;    }&#10;}&#10;&#10;class Tracker {&#10;public:&#10;    static int constructed;&#10;    static int destructed;&#10;&#10;    Tracker() {&#10;        constructed++;&#10;    }&#10;&#10;    Tracker(const Tracker &amp;) {&#10;        constructed++;&#10;    }&#10;&#10;    ~Tracker() {&#10;        destructed++;&#10;    }&#10;};&#10;&#10;int Tracker::constructed = 0;&#10;int Tracker::destructed = 0;&#10;&#10;TEST_CASE(&quot;Deque element construction/destruction count&quot;, &quot;[Deque][Lifetime]&quot;) {&#10;    Tracker::constructed = 0;&#10;    Tracker::destructed = 0;&#10;&#10;    constexpr int num_elements = 100; {&#10;        Deque&lt;Tracker&gt; deque;&#10;        for (int i = 0; i &lt; num_elements; ++i) {&#10;            deque.emplace_back();&#10;        }&#10;        REQUIRE(Tracker::constructed == num_elements);&#10;        REQUIRE(deque.size() == num_elements);&#10;    } // Deque goes out of scope, all elements should be destructed&#10;    REQUIRE(Tracker::destructed == num_elements);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>