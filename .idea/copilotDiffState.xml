<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Deque.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Deque.h" />
              <option name="originalContent" value="/// A Double Ended Queue (Deque)&#10;&#10;#pragma once&#10;&#10;#include &lt;algorithm&gt;&#10;#include &lt;array&gt;&#10;#include &lt;cassert&gt;&#10;#include &lt;cstddef&gt;&#10;#include &lt;memory&gt;&#10;&#10;#include &quot;CircularBuffer.h&quot;&#10;&#10;template&lt;typename T&gt;&#10;class Deque {&#10;    static constexpr size_t fixed_arr_n_elem = std::max((4096 + sizeof(T) - 1) / sizeof(T), 16zu);&#10;&#10;    struct alignas(4096) FixedArray {&#10;        // Page aligned&#10;        std::array&lt;std::byte, fixed_arr_n_elem * sizeof(T)&gt; data_storage{};&#10;        T *data{reinterpret_cast&lt;T *&gt;(data_storage.data())};&#10;        FixedArray *next{nullptr};&#10;        FixedArray *prev{nullptr};&#10;&#10;        template&lt;class Self&gt;&#10;        auto &amp;&amp;operator[](this Self &amp;&amp;self, size_t index) {&#10;            assert(index &lt; fixed_arr_n_elem &amp;&amp; &quot;Index out of bounds&quot;);&#10;            return self.data[index];&#10;        }&#10;    };&#10;&#10;    CircularBuffer&lt;std::unique_ptr&lt;FixedArray&gt; &gt; buffer{};&#10;    // Implicitly, these are on the first and last FixedArray, which may be the same&#10;    size_t first_idx = 0; // inv: 0 &lt;= first_idx &lt; fixed_arr_n_elem&#10;    size_t last_idx = 0; // inv: 0 &lt; last_idx &lt;= fixed_arr_n_elem&#10;    size_t size_{0};&#10;&#10;    template&lt;typename... Args&gt;&#10;    void emplace_front_impl(Args &amp;&amp;... value) {&#10;        if (first_idx == 0) [[unlikely]] {&#10;            buffer.push_front(std::make_unique&lt;FixedArray&gt;());&#10;            first_idx = fixed_arr_n_elem;&#10;        }&#10;        FixedArray &amp;first_array = *buffer.front();&#10;        --first_idx;&#10;        new(&amp;first_array[first_idx]) T(std::forward&lt;Args&gt;(value)...);&#10;        ++size_;&#10;    }&#10;&#10;    template&lt;typename... Args&gt;&#10;    void emplace_back_impl(Args &amp;&amp;... value) {&#10;        if (last_idx == fixed_arr_n_elem) [[unlikely]] {&#10;            buffer.push_back(std::make_unique&lt;FixedArray&gt;());&#10;            last_idx = 0;&#10;        }&#10;        FixedArray &amp;last_array = *buffer.back();&#10;        new(&amp;last_array[last_idx]) T(std::forward&lt;Args&gt;(value)...);&#10;        ++last_idx;&#10;        ++size_;&#10;    }&#10;&#10;    struct Iterator {&#10;        Deque&lt;T&gt; *deque{};&#10;        FixedArray *current_array{};&#10;        size_t index{};&#10;&#10;        T &amp;operator*() {&#10;            return current_array-&gt;data[index];&#10;        }&#10;&#10;        [[nodiscard]] Iterator next() const {&#10;            if (current_array == nullptr) {&#10;                return *this; // End of iteration&#10;            }&#10;            if (index == fixed_arr_n_elem - 1) {&#10;                return Iterator{deque, current_array-&gt;next, 0};&#10;            }&#10;&#10;            return Iterator{deque, current_array, index + 1};&#10;        }&#10;&#10;        [[nodiscard]] Iterator prev() const {&#10;            if (current_array == nullptr) {&#10;                return Iterator{deque, deque-&gt;buffer.back().get(), deque-&gt;last_idx - 1};&#10;            }&#10;            if (index == 0) {&#10;                return Iterator{deque, current_array-&gt;prev, fixed_arr_n_elem - 1};&#10;            }&#10;            return Iterator{deque, current_array, index - 1};&#10;        }&#10;&#10;        Iterator &amp;operator++() {&#10;            *this = next();&#10;            return *this;&#10;        }&#10;&#10;        Iterator operator++(int) {&#10;            Iterator temp = *this;&#10;            ++(*this);&#10;            return temp;&#10;        }&#10;&#10;        Iterator &amp;operator--() {&#10;            *this = prev();&#10;            return *this;&#10;        }&#10;&#10;        Iterator operator--(int) {&#10;            Iterator temp = *this;&#10;            --(*this);&#10;            return temp;&#10;        }&#10;&#10;        // Equality operators needed for range-based for loops&#10;        bool operator==(const Iterator&amp; other) const {&#10;            return deque == other.deque &amp;&amp;&#10;                   current_array == other.current_array &amp;&amp;&#10;                   index == other.index;&#10;        }&#10;&#10;        bool operator!=(const Iterator&amp; other) const {&#10;            return !(*this == other);&#10;        }&#10;    };&#10;&#10;public:&#10;    Deque() {&#10;        buffer.push_back(std::make_unique&lt;FixedArray&gt;());&#10;    }&#10;&#10;    Deque(std::initializer_list&lt;T&gt; init) {&#10;        buffer.push_back(std::make_unique&lt;FixedArray&gt;());&#10;        for (const auto &amp;value: init) {&#10;            emplace_back_impl(value);&#10;        }&#10;    }&#10;&#10;    void push_back(const T &amp;value) requires std::copy_constructible&lt;T&gt; {&#10;        emplace_back_impl(value);&#10;    }&#10;&#10;    void push_back(T &amp;&amp;value) requires std::move_constructible&lt;T&gt; {&#10;        emplace_back_impl(std::move(value));&#10;    }&#10;&#10;    template&lt;typename... Args&gt;&#10;    void emplace_back(Args &amp;&amp;... args) requires std::constructible_from&lt;T, Args...&gt; {&#10;        emplace_back_impl(std::forward&lt;Args&gt;(args)...);&#10;    }&#10;&#10;    void push_front(const T &amp;value) requires std::copy_constructible&lt;T&gt; {&#10;        emplace_front_impl(value);&#10;    }&#10;&#10;    void push_front(T &amp;&amp;value) requires std::move_constructible&lt;T&gt; {&#10;        emplace_front_impl(std::move(value));&#10;    }&#10;&#10;    template&lt;typename... Args&gt;&#10;    void emplace_front(Args &amp;&amp;... args) requires std::constructible_from&lt;T, Args...&gt; {&#10;        emplace_front_impl(std::forward&lt;Args&gt;(args)...);&#10;    }&#10;&#10;    T pop_back() {&#10;        assert(size_ &gt; 0 &amp;&amp; &quot;Cannot pop from an empty deque&quot;);&#10;        --size_;&#10;        --last_idx;&#10;        FixedArray &amp;last_array = *buffer.back();&#10;        T value = std::move(last_array[last_idx]);&#10;        if (last_idx == 0) [[unlikely]] {&#10;            // Remove the last FixedArray if it is empty&#10;            buffer.pop_back();&#10;            last_idx = fixed_arr_n_elem;&#10;        }&#10;        return value;&#10;    }&#10;&#10;    T pop_front() {&#10;        assert(size_ &gt; 0 &amp;&amp; &quot;Cannot pop from an empty deque&quot;);&#10;        --size_;&#10;        FixedArray &amp;first_array = *buffer.front();&#10;        T value = std::move(first_array[first_idx]);&#10;        ++first_idx;&#10;        if (first_idx == fixed_arr_n_elem) [[unlikely]] {&#10;            // Remove the first FixedArray if it is empty&#10;            buffer.pop_front();&#10;            first_idx = 0; // Reset to the start of the next FixedArray&#10;        }&#10;        return value;&#10;    }&#10;&#10;    template&lt;class Self&gt;&#10;    auto &amp;&amp;operator[](this Self &amp;&amp;self, const size_t index) {&#10;        assert(index &lt; self.size_ &amp;&amp; &quot;Index out of bounds&quot;);&#10;&#10;        const size_t first_size = fixed_arr_n_elem - self.first_idx;&#10;        if (index &lt; first_size) {&#10;            // Access within the first FixedArray&#10;            return (*self.buffer.front())[self.first_idx + index];&#10;        }&#10;&#10;        const size_t adjusted_index = index - first_size;&#10;        const size_t num_full_arrays = adjusted_index / fixed_arr_n_elem;&#10;        const size_t index_in_array = adjusted_index % fixed_arr_n_elem;&#10;        return (*self.buffer[num_full_arrays + 1])[index_in_array];&#10;    }&#10;&#10;    template&lt;typename Self&gt;&#10;    auto &amp;&amp;back(this Self &amp;&amp;self) {&#10;        assert(self.size_ &gt; 0 &amp;&amp; &quot;Deque is empty&quot;);&#10;        return (*self.buffer.back())[self.last_idx - 1];&#10;    }&#10;&#10;    template&lt;typename Self&gt;&#10;    auto &amp;&amp;front(this Self &amp;&amp;self) {&#10;        assert(self.size_ &gt; 0 &amp;&amp; &quot;Deque is empty&quot;);&#10;        return (*self.buffer.front())[self.first_idx];&#10;    }&#10;&#10;    Iterator begin() {&#10;        return Iterator{this, buffer.front().get(), first_idx};&#10;    }&#10;&#10;    Iterator end() {&#10;        return Iterator{this, nullptr, 0}; // End of iteration&#10;    }&#10;&#10;    [[nodiscard]] size_t size() const {&#10;        return size_;&#10;    }&#10;&#10;    [[nodiscard]] bool empty() const {&#10;        return size_ == 0;&#10;    }&#10;};&#10;&#10;// Explicit template instantiations for common types&#10;template class Deque&lt;int&gt;;&#10;template class Deque&lt;std::string&gt;;&#10;" />
              <option name="updatedContent" value="/// A Double Ended Queue (Deque)&#10;&#10;#pragma once&#10;&#10;#include &lt;algorithm&gt;&#10;#include &lt;array&gt;&#10;#include &lt;cassert&gt;&#10;#include &lt;cstddef&gt;&#10;#include &lt;memory&gt;&#10;&#10;#include &quot;CircularBuffer.h&quot;&#10;&#10;template&lt;typename T&gt;&#10;class Deque {&#10;    static constexpr size_t fixed_arr_n_elem = std::max((4096 + sizeof(T) - 1) / sizeof(T), 16zu);&#10;&#10;    struct alignas(4096) FixedArray {&#10;        // Page aligned&#10;        std::array&lt;std::byte, fixed_arr_n_elem * sizeof(T)&gt; data_storage{};&#10;        T *data{reinterpret_cast&lt;T *&gt;(data_storage.data())};&#10;        FixedArray *next{nullptr};&#10;        FixedArray *prev{nullptr};&#10;&#10;        template&lt;class Self&gt;&#10;        auto &amp;&amp;operator[](this Self &amp;&amp;self, size_t index) {&#10;            assert(index &lt; fixed_arr_n_elem &amp;&amp; &quot;Index out of bounds&quot;);&#10;            return self.data[index];&#10;        }&#10;    };&#10;&#10;    CircularBuffer&lt;std::unique_ptr&lt;FixedArray&gt; &gt; buffer{};&#10;    // Implicitly, these are on the first and last FixedArray, which may be the same&#10;    size_t first_idx = 0; // inv: 0 &lt;= first_idx &lt; fixed_arr_n_elem&#10;    size_t last_idx = 0; // inv: 0 &lt; last_idx &lt;= fixed_arr_n_elem&#10;    size_t size_{0};&#10;&#10;    template&lt;typename... Args&gt;&#10;    void emplace_front_impl(Args &amp;&amp;... value) {&#10;        if (first_idx == 0) [[unlikely]] {&#10;            buffer.push_front(std::make_unique&lt;FixedArray&gt;());&#10;            first_idx = fixed_arr_n_elem;&#10;        }&#10;        FixedArray &amp;first_array = *buffer.front();&#10;        --first_idx;&#10;        new(&amp;first_array[first_idx]) T(std::forward&lt;Args&gt;(value)...);&#10;        ++size_;&#10;    }&#10;&#10;    template&lt;typename... Args&gt;&#10;    void emplace_back_impl(Args &amp;&amp;... value) {&#10;        if (last_idx == fixed_arr_n_elem) [[unlikely]] {&#10;            buffer.push_back(std::make_unique&lt;FixedArray&gt;());&#10;            last_idx = 0;&#10;        }&#10;        FixedArray &amp;last_array = *buffer.back();&#10;        new(&amp;last_array[last_idx]) T(std::forward&lt;Args&gt;(value)...);&#10;        ++last_idx;&#10;        ++size_;&#10;    }&#10;&#10;    struct Iterator {&#10;        Deque&lt;T&gt; *deque{};&#10;        FixedArray *current_array{};&#10;        size_t index{};&#10;&#10;        T &amp;operator*() {&#10;            return current_array-&gt;data[index];&#10;        }&#10;&#10;        [[nodiscard]] Iterator next() const {&#10;            if (current_array == nullptr) {&#10;                return *this; // Already at end&#10;            }&#10;            &#10;            // Check if we're at the last element of the deque&#10;            if (current_array == deque-&gt;buffer.back().get() &amp;&amp; index == deque-&gt;last_idx - 1) {&#10;                return Iterator{deque, nullptr, 0}; // End iterator&#10;            }&#10;            &#10;            // Move to next position in current array&#10;            if (index + 1 &lt; fixed_arr_n_elem) {&#10;                return Iterator{deque, current_array, index + 1};&#10;            }&#10;            &#10;            // Move to next array&#10;            return Iterator{deque, current_array-&gt;next, 0};&#10;        }&#10;&#10;        [[nodiscard]] Iterator prev() const {&#10;            if (current_array == nullptr) {&#10;                // Coming from end, go to last valid element&#10;                return Iterator{deque, deque-&gt;buffer.back().get(), deque-&gt;last_idx - 1};&#10;            }&#10;            &#10;            // Check if we're at the first element of the deque&#10;            if (current_array == deque-&gt;buffer.front().get() &amp;&amp; index == deque-&gt;first_idx) {&#10;                return Iterator{deque, nullptr, 0}; // Before begin (invalid)&#10;            }&#10;            &#10;            // Move to previous position in current array&#10;            if (index &gt; 0) {&#10;                return Iterator{deque, current_array, index - 1};&#10;            }&#10;            &#10;            // Move to previous array&#10;            return Iterator{deque, current_array-&gt;prev, fixed_arr_n_elem - 1};&#10;        }&#10;&#10;        Iterator &amp;operator++() {&#10;            *this = next();&#10;            return *this;&#10;        }&#10;&#10;        Iterator operator++(int) {&#10;            Iterator temp = *this;&#10;            ++(*this);&#10;            return temp;&#10;        }&#10;&#10;        Iterator &amp;operator--() {&#10;            *this = prev();&#10;            return *this;&#10;        }&#10;&#10;        Iterator operator--(int) {&#10;            Iterator temp = *this;&#10;            --(*this);&#10;            return temp;&#10;        }&#10;&#10;        // Equality operators needed for range-based for loops&#10;        bool operator==(const Iterator&amp; other) const {&#10;            return deque == other.deque &amp;&amp; &#10;                   current_array == other.current_array &amp;&amp; &#10;                   index == other.index;&#10;        }&#10;&#10;        bool operator!=(const Iterator&amp; other) const {&#10;            return !(*this == other);&#10;        }&#10;    };&#10;&#10;public:&#10;    Deque() {&#10;        buffer.push_back(std::make_unique&lt;FixedArray&gt;());&#10;    }&#10;&#10;    Deque(std::initializer_list&lt;T&gt; init) {&#10;        buffer.push_back(std::make_unique&lt;FixedArray&gt;());&#10;        for (const auto &amp;value: init) {&#10;            emplace_back_impl(value);&#10;        }&#10;    }&#10;&#10;    void push_back(const T &amp;value) requires std::copy_constructible&lt;T&gt; {&#10;        emplace_back_impl(value);&#10;    }&#10;&#10;    void push_back(T &amp;&amp;value) requires std::move_constructible&lt;T&gt; {&#10;        emplace_back_impl(std::move(value));&#10;    }&#10;&#10;    template&lt;typename... Args&gt;&#10;    void emplace_back(Args &amp;&amp;... args) requires std::constructible_from&lt;T, Args...&gt; {&#10;        emplace_back_impl(std::forward&lt;Args&gt;(args)...);&#10;    }&#10;&#10;    void push_front(const T &amp;value) requires std::copy_constructible&lt;T&gt; {&#10;        emplace_front_impl(value);&#10;    }&#10;&#10;    void push_front(T &amp;&amp;value) requires std::move_constructible&lt;T&gt; {&#10;        emplace_front_impl(std::move(value));&#10;    }&#10;&#10;    template&lt;typename... Args&gt;&#10;    void emplace_front(Args &amp;&amp;... args) requires std::constructible_from&lt;T, Args...&gt; {&#10;        emplace_front_impl(std::forward&lt;Args&gt;(args)...);&#10;    }&#10;&#10;    T pop_back() {&#10;        assert(size_ &gt; 0 &amp;&amp; &quot;Cannot pop from an empty deque&quot;);&#10;        --size_;&#10;        --last_idx;&#10;        FixedArray &amp;last_array = *buffer.back();&#10;        T value = std::move(last_array[last_idx]);&#10;        if (last_idx == 0) [[unlikely]] {&#10;            // Remove the last FixedArray if it is empty&#10;            buffer.pop_back();&#10;            last_idx = fixed_arr_n_elem;&#10;        }&#10;        return value;&#10;    }&#10;&#10;    T pop_front() {&#10;        assert(size_ &gt; 0 &amp;&amp; &quot;Cannot pop from an empty deque&quot;);&#10;        --size_;&#10;        FixedArray &amp;first_array = *buffer.front();&#10;        T value = std::move(first_array[first_idx]);&#10;        ++first_idx;&#10;        if (first_idx == fixed_arr_n_elem) [[unlikely]] {&#10;            // Remove the first FixedArray if it is empty&#10;            buffer.pop_front();&#10;            first_idx = 0; // Reset to the start of the next FixedArray&#10;        }&#10;        return value;&#10;    }&#10;&#10;    template&lt;class Self&gt;&#10;    auto &amp;&amp;operator[](this Self &amp;&amp;self, const size_t index) {&#10;        assert(index &lt; self.size_ &amp;&amp; &quot;Index out of bounds&quot;);&#10;&#10;        const size_t first_size = fixed_arr_n_elem - self.first_idx;&#10;        if (index &lt; first_size) {&#10;            // Access within the first FixedArray&#10;            return (*self.buffer.front())[self.first_idx + index];&#10;        }&#10;&#10;        const size_t adjusted_index = index - first_size;&#10;        const size_t num_full_arrays = adjusted_index / fixed_arr_n_elem;&#10;        const size_t index_in_array = adjusted_index % fixed_arr_n_elem;&#10;        return (*self.buffer[num_full_arrays + 1])[index_in_array];&#10;    }&#10;&#10;    template&lt;typename Self&gt;&#10;    auto &amp;&amp;back(this Self &amp;&amp;self) {&#10;        assert(self.size_ &gt; 0 &amp;&amp; &quot;Deque is empty&quot;);&#10;        return (*self.buffer.back())[self.last_idx - 1];&#10;    }&#10;&#10;    template&lt;typename Self&gt;&#10;    auto &amp;&amp;front(this Self &amp;&amp;self) {&#10;        assert(self.size_ &gt; 0 &amp;&amp; &quot;Deque is empty&quot;);&#10;        return (*self.buffer.front())[self.first_idx];&#10;    }&#10;&#10;    Iterator begin() {&#10;        return Iterator{this, buffer.front().get(), first_idx};&#10;    }&#10;&#10;    Iterator end() {&#10;        return Iterator{this, nullptr, 0}; // End of iteration&#10;    }&#10;&#10;    [[nodiscard]] size_t size() const {&#10;        return size_;&#10;    }&#10;&#10;    [[nodiscard]] bool empty() const {&#10;        return size_ == 0;&#10;    }&#10;};&#10;&#10;// Explicit template instantiations for common types&#10;template class Deque&lt;int&gt;;&#10;template class Deque&lt;std::string&gt;;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/test_deque.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/test_deque.cpp" />
              <option name="originalContent" value="#include &lt;catch2/catch_test_macros.hpp&gt;&#10;#include &quot;Deque.h&quot;&#10;#include &lt;string&gt;&#10;&#10;TEST_CASE(&quot;Deque construction&quot;, &quot;[Deque]&quot;) {&#10;    SECTION(&quot;Default construction&quot;) {&#10;        const Deque&lt;int&gt; deque;&#10;        REQUIRE(deque.size() == 0); // NOLINT&#10;    }&#10;}&#10;&#10;TEST_CASE(&quot;Deque push_back operations&quot;, &quot;[Deque]&quot;) {&#10;    Deque&lt;int&gt; deque;&#10;&#10;    SECTION(&quot;Push single element&quot;) {&#10;        deque.push_back(42);&#10;        REQUIRE(deque.size() == 1);&#10;        REQUIRE(deque[0] == 42);&#10;    }&#10;&#10;    SECTION(&quot;Push multiple elements&quot;) {&#10;        for (int i = 0; i &lt; 10; ++i) {&#10;            deque.push_back(i);&#10;        }&#10;        REQUIRE(deque.size() == 10);&#10;        for (int i = 0; i &lt; 10; ++i) {&#10;            REQUIRE(deque[i] == i);&#10;        }&#10;    }&#10;&#10;    SECTION(&quot;Push beyond single FixedArray capacity&quot;) {&#10;        // Push enough elements to trigger multiple FixedArrays&#10;        constexpr int num_elements = 5000; // More than fixed_arr_n_elem&#10;        for (int i = 0; i &lt; num_elements; ++i) {&#10;            deque.push_back(i);&#10;        }&#10;        REQUIRE(deque.size() == num_elements);&#10;        // Verify all elements are accessible and correct&#10;        for (int i = 0; i &lt; num_elements; ++i) {&#10;            REQUIRE(deque[i] == i);&#10;        }&#10;    }&#10;}&#10;&#10;TEST_CASE(&quot;Deque push_front operations&quot;, &quot;[Deque]&quot;) {&#10;    Deque&lt;int&gt; deque;&#10;&#10;    SECTION(&quot;Push single element to front&quot;) {&#10;        deque.push_front(42);&#10;        REQUIRE(deque.size() == 1);&#10;        REQUIRE(deque[0] == 42);&#10;    }&#10;&#10;    SECTION(&quot;Push multiple elements to front&quot;) {&#10;        for (int i = 0; i &lt; 10; ++i) {&#10;            deque.push_front(i);&#10;        }&#10;        REQUIRE(deque.size() == 10);&#10;        // Elements should be in reverse order&#10;        for (int i = 0; i &lt; 10; ++i) {&#10;            REQUIRE(deque[i] == 9 - i);&#10;        }&#10;    }&#10;&#10;    SECTION(&quot;Mix push_front and push_back&quot;) {&#10;        deque.push_back(1);&#10;        deque.push_back(2);&#10;        deque.push_front(0);&#10;        deque.push_front(-1);&#10;&#10;        REQUIRE(deque.size() == 4);&#10;        REQUIRE(deque[0] == -1);&#10;        REQUIRE(deque[1] == 0);&#10;        REQUIRE(deque[2] == 1);&#10;        REQUIRE(deque[3] == 2);&#10;    }&#10;}&#10;&#10;TEST_CASE(&quot;Deque pop operations&quot;, &quot;[Deque]&quot;) {&#10;    Deque&lt;int&gt; deque;&#10;&#10;    SECTION(&quot;Pop from back&quot;) {&#10;        deque.push_back(1);&#10;        deque.push_back(2);&#10;        deque.push_back(3);&#10;&#10;        REQUIRE(deque.pop_back() == 3);&#10;        REQUIRE(deque.size() == 2);&#10;        REQUIRE(deque.pop_back() == 2);&#10;        REQUIRE(deque.size() == 1);&#10;        REQUIRE(deque.pop_back() == 1);&#10;        REQUIRE(deque.size() == 0); // NOLINT&#10;    }&#10;&#10;    SECTION(&quot;Pop from front&quot;) {&#10;        deque.push_back(1);&#10;        deque.push_back(2);&#10;        deque.push_back(3);&#10;&#10;        REQUIRE(deque.pop_front() == 1);&#10;        REQUIRE(deque.size() == 2);&#10;        REQUIRE(deque.pop_front() == 2);&#10;        REQUIRE(deque.size() == 1);&#10;        REQUIRE(deque.pop_front() == 3);&#10;        REQUIRE(deque.size() == 0); // NOLINT&#10;    }&#10;&#10;    SECTION(&quot;Mix pop operations&quot;) {&#10;        for (int i = 0; i &lt; 10; ++i) {&#10;            deque.push_back(i);&#10;        }&#10;&#10;        REQUIRE(deque.pop_front() == 0);&#10;        REQUIRE(deque.pop_back() == 9);&#10;        REQUIRE(deque.pop_front() == 1);&#10;        REQUIRE(deque.pop_back() == 8);&#10;&#10;        REQUIRE(deque.size() == 6);&#10;        REQUIRE(deque[0] == 2);&#10;        REQUIRE(deque[5] == 7);&#10;    }&#10;}&#10;&#10;TEST_CASE(&quot;Deque operator[] access&quot;, &quot;[Deque]&quot;) {&#10;    Deque&lt;int&gt; deque;&#10;&#10;    SECTION(&quot;Random access after mixed operations&quot;) {&#10;        // Fill deque with pattern&#10;        for (int i = 0; i &lt; 100; ++i) {&#10;            if (i % 2 == 0) {&#10;                deque.push_back(i);&#10;            } else {&#10;                deque.push_front(-i);&#10;            }&#10;        }&#10;&#10;        // Verify all elements are accessible&#10;        for (size_t i = 0; i &lt; deque.size(); ++i) {&#10;            // This should not throw and should return a valid value&#10;            REQUIRE_NOTHROW(deque[i]);&#10;        }&#10;    }&#10;&#10;    SECTION(&quot;Access across multiple FixedArrays&quot;) {&#10;        constexpr int num_elements = 10000;&#10;        for (int i = 0; i &lt; num_elements; ++i) {&#10;            deque.push_back(i * 2); // Use a pattern to verify correctness&#10;        }&#10;&#10;        // Test random access across the entire range&#10;        for (int i = 0; i &lt; num_elements; ++i) {&#10;            REQUIRE(deque[i] == i * 2);&#10;        }&#10;&#10;        // Test access at boundaries&#10;        REQUIRE(deque[0] == 0);&#10;        REQUIRE(deque[num_elements - 1] == (num_elements - 1) * 2);&#10;    }&#10;}&#10;&#10;TEST_CASE(&quot;Deque with strings&quot;, &quot;[Deque]&quot;) {&#10;    SECTION(&quot;String operations&quot;) {&#10;        Deque&lt;std::string&gt; deque;&#10;        deque.push_back(std::string(&quot;hello&quot;));&#10;        deque.push_back(&quot;world&quot;);&#10;        deque.push_front(&quot;hi&quot;);&#10;&#10;        REQUIRE(deque.size() == 3);&#10;        REQUIRE(deque[0] == &quot;hi&quot;);&#10;        REQUIRE(deque[1] == &quot;hello&quot;);&#10;        REQUIRE(deque[2] == &quot;world&quot;);&#10;&#10;        REQUIRE(deque.pop_back() == &quot;world&quot;);&#10;        REQUIRE(deque.pop_front() == &quot;hi&quot;);&#10;        REQUIRE(deque[0] == &quot;hello&quot;);&#10;    }&#10;}&#10;&#10;TEST_CASE(&quot;Deque stress test&quot;, &quot;[Deque][Stress]&quot;) {&#10;    Deque&lt;int&gt; deque;&#10;&#10;    SECTION(&quot;Large scale operations&quot;) {&#10;        constexpr int operations = 50000;&#10;&#10;        // Add many elements&#10;        for (int i = 0; i &lt; operations; ++i) {&#10;            deque.push_back(i);&#10;        }&#10;        REQUIRE(deque.size() == operations);&#10;&#10;        // Remove half from front&#10;        for (int i = 0; i &lt; operations / 2; ++i) {&#10;            REQUIRE(deque.pop_front() == i);&#10;        }&#10;        REQUIRE(deque.size() == operations / 2);&#10;&#10;        // Add more to front&#10;        for (int i = 0; i &lt; operations / 4; ++i) {&#10;            deque.push_front(-i - 1);&#10;        }&#10;&#10;        // Verify size and some elements&#10;        REQUIRE(deque.size() == operations / 2 + operations / 4);&#10;        REQUIRE(deque[0] == -operations / 4);&#10;        REQUIRE(deque[operations / 4] == operations / 2);&#10;    }&#10;&#10;    SECTION(&quot;Alternating push/pop pattern&quot;) {&#10;        // This tests the dynamic resizing behavior&#10;        for (int cycle = 0; cycle &lt; 1000; ++cycle) {&#10;            // Push a bunch&#10;            for (int i = 0; i &lt; 100; ++i) {&#10;                deque.push_back(cycle * 100 + i);&#10;            }&#10;&#10;            // Pop some&#10;            for (int i = 0; i &lt; 50; ++i) {&#10;                deque.pop_front();&#10;            }&#10;        }&#10;&#10;        // Should still be functional&#10;        REQUIRE(deque.size() == 50000); // 1000 * (100 - 50)&#10;&#10;        // Test random access still works&#10;        for (size_t i = 0; i &lt; std::min(deque.size(), size_t(100)); ++i) {&#10;            REQUIRE_NOTHROW(deque[i]);&#10;        }&#10;    }&#10;}&#10;&#10;TEST_CASE(&quot;Deque Constructors&quot;, &quot;[Deque]&quot;) {&#10;    SECTION(&quot;Initializer list construction&quot;) {&#10;        const Deque deque = {1, 2, 3, 4, 5};&#10;        REQUIRE(deque.size() == 5);&#10;        REQUIRE(deque[0] == 1);&#10;        REQUIRE(deque[1] == 2);&#10;        REQUIRE(deque[2] == 3);&#10;        REQUIRE(deque[3] == 4);&#10;        REQUIRE(deque[4] == 5);&#10;        REQUIRE(deque.front() == 1);&#10;        REQUIRE(deque.back() == 5);&#10;    }&#10;&#10;    SECTION(&quot;Initializer list with strings&quot;) {&#10;        Deque&lt;std::string&gt; deque = {&quot;one&quot;, &quot;two&quot;, &quot;three&quot;};&#10;        REQUIRE(deque.size() == 3);&#10;        REQUIRE(deque[0] == &quot;one&quot;);&#10;        REQUIRE(deque[1] == &quot;two&quot;);&#10;        REQUIRE(deque[2] == &quot;three&quot;);&#10;    }&#10;}&#10;&#10;TEST_CASE(&quot;Deque Iterator operations&quot;, &quot;[Deque][Iterator]&quot;) {&#10;    SECTION(&quot;Basic iterator functionality&quot;) {&#10;        Deque&lt;int&gt; deque = {1, 2, 3, 4, 5};&#10;        &#10;        // Test begin() and end()&#10;        auto it = deque.begin();&#10;        auto end_it = deque.end();&#10;        &#10;        REQUIRE(*it == 1);&#10;        &#10;        // Test dereference operator&#10;        REQUIRE(*it == 1);&#10;        *it = 10;&#10;        REQUIRE(*it == 10);&#10;        REQUIRE(deque[0] == 10);&#10;&#10;        RE&#10;    }&#10;    &#10;    SECTION(&quot;Iterator increment operations&quot;) {&#10;        Deque&lt;int&gt; deque = {1, 2, 3, 4, 5};&#10;        auto it = deque.begin();&#10;        &#10;        // Test prefix increment&#10;        REQUIRE(*it == 1);&#10;        ++it;&#10;        REQUIRE(*it == 2);&#10;        ++it;&#10;        REQUIRE(*it == 3);&#10;        &#10;        // Test postfix increment&#10;        auto old_it = it++;&#10;        REQUIRE(*old_it == 3);&#10;        REQUIRE(*it == 4);&#10;    }&#10;    &#10;    SECTION(&quot;Iterator decrement operations&quot;) {&#10;        Deque&lt;int&gt; deque = {1, 2, 3, 4, 5};&#10;        auto it = deque.begin();&#10;        &#10;        // Move to middle&#10;        ++it;&#10;        ++it;&#10;        REQUIRE(*it == 3);&#10;        &#10;        // Test prefix decrement&#10;        --it;&#10;        REQUIRE(*it == 2);&#10;        --it;&#10;        REQUIRE(*it == 1);&#10;        &#10;        // Test postfix decrement&#10;        ++it;&#10;        ++it;&#10;        REQUIRE(*it == 3);&#10;        auto old_it = it--;&#10;        REQUIRE(*old_it == 3);&#10;        REQUIRE(*it == 2);&#10;    }&#10;    &#10;    SECTION(&quot;Iterator traversal&quot;) {&#10;        Deque&lt;int&gt; deque;&#10;        for (int i = 0; i &lt; 10; ++i) {&#10;            deque.push_back(i);&#10;        }&#10;        &#10;        // Forward traversal&#10;        int expected = 0;&#10;        for (auto it = deque.begin(); it.current_array != nullptr; ++it) {&#10;            REQUIRE(*it == expected);&#10;            ++expected;&#10;        }&#10;        REQUIRE(expected == 10);&#10;        &#10;        // Manual traversal using next()&#10;        auto it = deque.begin();&#10;        for (int i = 0; i &lt; 10; ++i) {&#10;            REQUIRE(*it == i);&#10;            it = it.next();&#10;        }&#10;        REQUIRE(it.current_array == nullptr); // Should be at end&#10;    }&#10;    &#10;    SECTION(&quot;Iterator with large deque across multiple FixedArrays&quot;) {&#10;        Deque&lt;int&gt; deque;&#10;        constexpr int num_elements = 10000; // Ensure multiple FixedArrays&#10;        &#10;        for (int i = 0; i &lt; num_elements; ++i) {&#10;            deque.push_back(i);&#10;        }&#10;        &#10;        // Test forward iteration through all elements&#10;        int count = 0;&#10;        for (auto it = deque.begin(); it.current_array != nullptr; ++it) {&#10;            REQUIRE(*it == count);&#10;            ++count;&#10;        }&#10;        REQUIRE(count == num_elements);&#10;        &#10;        // Test that we can modify elements through iterator&#10;        auto it = deque.begin();&#10;        for (int i = 0; i &lt; 100; ++i) {&#10;            *it = i * 10;&#10;            ++it;&#10;        }&#10;        &#10;        // Verify modifications&#10;        for (int i = 0; i &lt; 100; ++i) {&#10;            REQUIRE(deque[i] == i * 10);&#10;        }&#10;    }&#10;    &#10;    SECTION(&quot;Iterator with mixed push operations&quot;) {&#10;        Deque&lt;int&gt; deque;&#10;        &#10;        // Create a pattern: push_front some, push_back some&#10;        for (int i = 0; i &lt; 5; ++i) {&#10;            deque.push_front(-i - 1);  // -1, -2, -3, -4, -5&#10;            deque.push_back(i + 1);    //  1,  2,  3,  4,  5&#10;        }&#10;        &#10;        // Expected order: [-5, -4, -3, -2, -1, 1, 2, 3, 4, 5]&#10;        std::vector&lt;int&gt; expected = {-5, -4, -3, -2, -1, 1, 2, 3, 4, 5};&#10;        &#10;        int index = 0;&#10;        for (auto it = deque.begin(); it.current_array != nullptr; ++it) {&#10;            REQUIRE(*it == expected[index]);&#10;            ++index;&#10;        }&#10;        REQUIRE(index == expected.size());&#10;    }&#10;    &#10;    SECTION(&quot;Range-based for loop&quot;) {&#10;        Deque&lt;std::string&gt; deque = {&quot;hello&quot;, &quot;world&quot;, &quot;test&quot;};&#10;        &#10;        std::vector&lt;std::string&gt; collected;&#10;        for (const auto&amp; item : deque) {&#10;            collected.push_back(item);&#10;        }&#10;        &#10;        REQUIRE(collected.size() == 3);&#10;        REQUIRE(collected[0] == &quot;hello&quot;);&#10;        REQUIRE(collected[1] == &quot;world&quot;);&#10;        REQUIRE(collected[2] == &quot;test&quot;);&#10;    }&#10;    &#10;    SECTION(&quot;Empty deque iterator&quot;) {&#10;        Deque&lt;int&gt; deque;&#10;        &#10;        auto begin_it = deque.begin();&#10;        auto end_it = deque.end();&#10;        &#10;        // For empty deque, begin should point to end immediately&#10;        REQUIRE(begin_it.current_array != nullptr); // Points to the initial FixedArray&#10;        REQUIRE(end_it.current_array == nullptr);&#10;        &#10;        // Incrementing begin should reach end quickly&#10;        ++begin_it;&#10;        REQUIRE(begin_it.current_array == nullptr);&#10;    }&#10;    &#10;    SECTION(&quot;Iterator prev() method&quot;) {&#10;        Deque&lt;int&gt; deque = {1, 2, 3, 4, 5};&#10;        &#10;        // Start from end and work backwards using prev()&#10;        auto it = deque.end().prev();&#10;        REQUIRE(*it == 5);&#10;        &#10;        it = it.prev();&#10;        REQUIRE(*it == 4);&#10;        &#10;        it = it.prev();&#10;        REQUIRE(*it == 3);&#10;        &#10;        it = it.prev();&#10;        REQUIRE(*it == 2);&#10;        &#10;        it = it.prev();&#10;        REQUIRE(*it == 1);&#10;    }&#10;    &#10;    SECTION(&quot;Iterator boundary conditions&quot;) {&#10;        Deque&lt;int&gt; deque;&#10;        &#10;        // Test with exactly one element&#10;        deque.push_back(42);&#10;        auto it = deque.begin();&#10;        REQUIRE(*it == 42);&#10;        &#10;        ++it;&#10;        REQUIRE(it.current_array == nullptr); // Should be at end&#10;        &#10;        // Test prev from end&#10;        it = deque.end().prev();&#10;        REQUIRE(*it == 42);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="#include &lt;catch2/catch_test_macros.hpp&gt;&#10;#include &quot;Deque.h&quot;&#10;#include &lt;string&gt;&#10;#include &lt;vector&gt;&#10;&#10;TEST_CASE(&quot;Deque construction&quot;, &quot;[Deque]&quot;) {&#10;    SECTION(&quot;Default construction&quot;) {&#10;        const Deque&lt;int&gt; deque;&#10;        REQUIRE(deque.size() == 0); // NOLINT&#10;    }&#10;}&#10;&#10;TEST_CASE(&quot;Deque push_back operations&quot;, &quot;[Deque]&quot;) {&#10;    Deque&lt;int&gt; deque;&#10;&#10;    SECTION(&quot;Push single element&quot;) {&#10;        deque.push_back(42);&#10;        REQUIRE(deque.size() == 1);&#10;        REQUIRE(deque[0] == 42);&#10;    }&#10;&#10;    SECTION(&quot;Push multiple elements&quot;) {&#10;        for (int i = 0; i &lt; 10; ++i) {&#10;            deque.push_back(i);&#10;        }&#10;        REQUIRE(deque.size() == 10);&#10;        for (int i = 0; i &lt; 10; ++i) {&#10;            REQUIRE(deque[i] == i);&#10;        }&#10;    }&#10;&#10;    SECTION(&quot;Push beyond single FixedArray capacity&quot;) {&#10;        // Push enough elements to trigger multiple FixedArrays&#10;        constexpr int num_elements = 5000; // More than fixed_arr_n_elem&#10;        for (int i = 0; i &lt; num_elements; ++i) {&#10;            deque.push_back(i);&#10;        }&#10;        REQUIRE(deque.size() == num_elements);&#10;        // Verify all elements are accessible and correct&#10;        for (int i = 0; i &lt; num_elements; ++i) {&#10;            REQUIRE(deque[i] == i);&#10;        }&#10;    }&#10;}&#10;&#10;TEST_CASE(&quot;Deque push_front operations&quot;, &quot;[Deque]&quot;) {&#10;    Deque&lt;int&gt; deque;&#10;&#10;    SECTION(&quot;Push single element to front&quot;) {&#10;        deque.push_front(42);&#10;        REQUIRE(deque.size() == 1);&#10;        REQUIRE(deque[0] == 42);&#10;    }&#10;&#10;    SECTION(&quot;Push multiple elements to front&quot;) {&#10;        for (int i = 0; i &lt; 10; ++i) {&#10;            deque.push_front(i);&#10;        }&#10;        REQUIRE(deque.size() == 10);&#10;        // Elements should be in reverse order&#10;        for (int i = 0; i &lt; 10; ++i) {&#10;            REQUIRE(deque[i] == 9 - i);&#10;        }&#10;    }&#10;&#10;    SECTION(&quot;Mix push_front and push_back&quot;) {&#10;        deque.push_back(1);&#10;        deque.push_back(2);&#10;        deque.push_front(0);&#10;        deque.push_front(-1);&#10;&#10;        REQUIRE(deque.size() == 4);&#10;        REQUIRE(deque[0] == -1);&#10;        REQUIRE(deque[1] == 0);&#10;        REQUIRE(deque[2] == 1);&#10;        REQUIRE(deque[3] == 2);&#10;    }&#10;}&#10;&#10;TEST_CASE(&quot;Deque pop operations&quot;, &quot;[Deque]&quot;) {&#10;    Deque&lt;int&gt; deque;&#10;&#10;    SECTION(&quot;Pop from back&quot;) {&#10;        deque.push_back(1);&#10;        deque.push_back(2);&#10;        deque.push_back(3);&#10;&#10;        REQUIRE(deque.pop_back() == 3);&#10;        REQUIRE(deque.size() == 2);&#10;        REQUIRE(deque.pop_back() == 2);&#10;        REQUIRE(deque.size() == 1);&#10;        REQUIRE(deque.pop_back() == 1);&#10;        REQUIRE(deque.size() == 0); // NOLINT&#10;    }&#10;&#10;    SECTION(&quot;Pop from front&quot;) {&#10;        deque.push_back(1);&#10;        deque.push_back(2);&#10;        deque.push_back(3);&#10;&#10;        REQUIRE(deque.pop_front() == 1);&#10;        REQUIRE(deque.size() == 2);&#10;        REQUIRE(deque.pop_front() == 2);&#10;        REQUIRE(deque.size() == 1);&#10;        REQUIRE(deque.pop_front() == 3);&#10;        REQUIRE(deque.size() == 0); // NOLINT&#10;    }&#10;&#10;    SECTION(&quot;Mix pop operations&quot;) {&#10;        for (int i = 0; i &lt; 10; ++i) {&#10;            deque.push_back(i);&#10;        }&#10;&#10;        REQUIRE(deque.pop_front() == 0);&#10;        REQUIRE(deque.pop_back() == 9);&#10;        REQUIRE(deque.pop_front() == 1);&#10;        REQUIRE(deque.pop_back() == 8);&#10;&#10;        REQUIRE(deque.size() == 6);&#10;        REQUIRE(deque[0] == 2);&#10;        REQUIRE(deque[5] == 7);&#10;    }&#10;}&#10;&#10;TEST_CASE(&quot;Deque operator[] access&quot;, &quot;[Deque]&quot;) {&#10;    Deque&lt;int&gt; deque;&#10;&#10;    SECTION(&quot;Random access after mixed operations&quot;) {&#10;        // Fill deque with pattern&#10;        for (int i = 0; i &lt; 100; ++i) {&#10;            if (i % 2 == 0) {&#10;                deque.push_back(i);&#10;            } else {&#10;                deque.push_front(-i);&#10;            }&#10;        }&#10;&#10;        // Verify all elements are accessible&#10;        for (size_t i = 0; i &lt; deque.size(); ++i) {&#10;            // This should not throw and should return a valid value&#10;            REQUIRE_NOTHROW(deque[i]);&#10;        }&#10;    }&#10;&#10;    SECTION(&quot;Access across multiple FixedArrays&quot;) {&#10;        constexpr int num_elements = 10000;&#10;        for (int i = 0; i &lt; num_elements; ++i) {&#10;            deque.push_back(i * 2); // Use a pattern to verify correctness&#10;        }&#10;&#10;        // Test random access across the entire range&#10;        for (int i = 0; i &lt; num_elements; ++i) {&#10;            REQUIRE(deque[i] == i * 2);&#10;        }&#10;&#10;        // Test access at boundaries&#10;        REQUIRE(deque[0] == 0);&#10;        REQUIRE(deque[num_elements - 1] == (num_elements - 1) * 2);&#10;    }&#10;}&#10;&#10;TEST_CASE(&quot;Deque with strings&quot;, &quot;[Deque]&quot;) {&#10;    SECTION(&quot;String operations&quot;) {&#10;        Deque&lt;std::string&gt; deque;&#10;        deque.push_back(std::string(&quot;hello&quot;));&#10;        deque.push_back(&quot;world&quot;);&#10;        deque.push_front(&quot;hi&quot;);&#10;&#10;        REQUIRE(deque.size() == 3);&#10;        REQUIRE(deque[0] == &quot;hi&quot;);&#10;        REQUIRE(deque[1] == &quot;hello&quot;);&#10;        REQUIRE(deque[2] == &quot;world&quot;);&#10;&#10;        REQUIRE(deque.pop_back() == &quot;world&quot;);&#10;        REQUIRE(deque.pop_front() == &quot;hi&quot;);&#10;        REQUIRE(deque[0] == &quot;hello&quot;);&#10;    }&#10;}&#10;&#10;TEST_CASE(&quot;Deque stress test&quot;, &quot;[Deque][Stress]&quot;) {&#10;    Deque&lt;int&gt; deque;&#10;&#10;    SECTION(&quot;Large scale operations&quot;) {&#10;        constexpr int operations = 50000;&#10;&#10;        // Add many elements&#10;        for (int i = 0; i &lt; operations; ++i) {&#10;            deque.push_back(i);&#10;        }&#10;        REQUIRE(deque.size() == operations);&#10;&#10;        // Remove half from front&#10;        for (int i = 0; i &lt; operations / 2; ++i) {&#10;            REQUIRE(deque.pop_front() == i);&#10;        }&#10;        REQUIRE(deque.size() == operations / 2);&#10;&#10;        // Add more to front&#10;        for (int i = 0; i &lt; operations / 4; ++i) {&#10;            deque.push_front(-i - 1);&#10;        }&#10;&#10;        // Verify size and some elements&#10;        REQUIRE(deque.size() == operations / 2 + operations / 4);&#10;        REQUIRE(deque[0] == -operations / 4);&#10;        REQUIRE(deque[operations / 4] == operations / 2);&#10;    }&#10;&#10;    SECTION(&quot;Alternating push/pop pattern&quot;) {&#10;        // This tests the dynamic resizing behavior&#10;        for (int cycle = 0; cycle &lt; 1000; ++cycle) {&#10;            // Push a bunch&#10;            for (int i = 0; i &lt; 100; ++i) {&#10;                deque.push_back(cycle * 100 + i);&#10;            }&#10;&#10;            // Pop some&#10;            for (int i = 0; i &lt; 50; ++i) {&#10;                deque.pop_front();&#10;            }&#10;        }&#10;&#10;        // Should still be functional&#10;        REQUIRE(deque.size() == 50000); // 1000 * (100 - 50)&#10;&#10;        // Test random access still works&#10;        for (size_t i = 0; i &lt; std::min(deque.size(), size_t(100)); ++i) {&#10;            REQUIRE_NOTHROW(deque[i]);&#10;        }&#10;    }&#10;}&#10;&#10;TEST_CASE(&quot;Deque Constructors&quot;, &quot;[Deque]&quot;) {&#10;    SECTION(&quot;Initializer list construction&quot;) {&#10;        const Deque deque = {1, 2, 3, 4, 5};&#10;        REQUIRE(deque.size() == 5);&#10;        REQUIRE(deque[0] == 1);&#10;        REQUIRE(deque[1] == 2);&#10;        REQUIRE(deque[2] == 3);&#10;        REQUIRE(deque[3] == 4);&#10;        REQUIRE(deque[4] == 5);&#10;        REQUIRE(deque.front() == 1);&#10;        REQUIRE(deque.back() == 5);&#10;    }&#10;&#10;    SECTION(&quot;Initializer list with strings&quot;) {&#10;        Deque&lt;std::string&gt; deque = {&quot;one&quot;, &quot;two&quot;, &quot;three&quot;};&#10;        REQUIRE(deque.size() == 3);&#10;        REQUIRE(deque[0] == &quot;one&quot;);&#10;        REQUIRE(deque[1] == &quot;two&quot;);&#10;        REQUIRE(deque[2] == &quot;three&quot;);&#10;    }&#10;}&#10;&#10;TEST_CASE(&quot;Deque Iterator operations&quot;, &quot;[Deque][Iterator]&quot;) {&#10;    SECTION(&quot;Basic iterator functionality&quot;) {&#10;        Deque&lt;int&gt; deque = {1, 2, 3, 4, 5};&#10;        &#10;        // Test begin() and end()&#10;        auto it = deque.begin();&#10;        &#10;        REQUIRE(*it == 1);&#10;        &#10;        // Test dereference operator&#10;        REQUIRE(*it == 1);&#10;        *it = 10;&#10;        REQUIRE(*it == 10);&#10;        REQUIRE(deque[0] == 10);&#10;    }&#10;    &#10;    SECTION(&quot;Iterator increment operations&quot;) {&#10;        Deque&lt;int&gt; deque = {1, 2, 3, 4, 5};&#10;        auto it = deque.begin();&#10;        &#10;        // Test prefix increment&#10;        REQUIRE(*it == 1);&#10;        ++it;&#10;        REQUIRE(*it == 2);&#10;        ++it;&#10;        REQUIRE(*it == 3);&#10;        &#10;        // Test postfix increment&#10;        auto old_it = it++;&#10;        REQUIRE(*old_it == 3);&#10;        REQUIRE(*it == 4);&#10;    }&#10;    &#10;    SECTION(&quot;Iterator decrement operations&quot;) {&#10;        Deque&lt;int&gt; deque = {1, 2, 3, 4, 5};&#10;        auto it = deque.begin();&#10;        &#10;        // Move to middle&#10;        ++it;&#10;        ++it;&#10;        REQUIRE(*it == 3);&#10;        &#10;        // Test prefix decrement&#10;        --it;&#10;        REQUIRE(*it == 2);&#10;        --it;&#10;        REQUIRE(*it == 1);&#10;        &#10;        // Test postfix decrement&#10;        ++it;&#10;        ++it;&#10;        REQUIRE(*it == 3);&#10;        auto old_it = it--;&#10;        REQUIRE(*old_it == 3);&#10;        REQUIRE(*it == 2);&#10;    }&#10;    &#10;    SECTION(&quot;Iterator traversal&quot;) {&#10;        Deque&lt;int&gt; deque;&#10;        for (int i = 0; i &lt; 10; ++i) {&#10;            deque.push_back(i);&#10;        }&#10;        &#10;        // Forward traversal&#10;        int expected = 0;&#10;        for (auto it = deque.begin(); it.current_array != nullptr; ++it) {&#10;            REQUIRE(*it == expected);&#10;            ++expected;&#10;        }&#10;        REQUIRE(expected == 10);&#10;        &#10;        // Manual traversal using next()&#10;        auto it = deque.begin();&#10;        for (int i = 0; i &lt; 10; ++i) {&#10;            REQUIRE(*it == i);&#10;            it = it.next();&#10;        }&#10;        REQUIRE(it.current_array == nullptr); // Should be at end&#10;    }&#10;    &#10;    SECTION(&quot;Iterator with large deque across multiple FixedArrays&quot;) {&#10;        Deque&lt;int&gt; deque;&#10;        constexpr int num_elements = 10000; // Ensure multiple FixedArrays&#10;        &#10;        for (int i = 0; i &lt; num_elements; ++i) {&#10;            deque.push_back(i);&#10;        }&#10;        &#10;        // Test forward iteration through all elements&#10;        int count = 0;&#10;        for (auto it = deque.begin(); it.current_array != nullptr; ++it) {&#10;            REQUIRE(*it == count);&#10;            ++count;&#10;        }&#10;        REQUIRE(count == num_elements);&#10;        &#10;        // Test that we can modify elements through iterator&#10;        auto it = deque.begin();&#10;        for (int i = 0; i &lt; 100; ++i) {&#10;            *it = i * 10;&#10;            ++it;&#10;        }&#10;        &#10;        // Verify modifications&#10;        for (int i = 0; i &lt; 100; ++i) {&#10;            REQUIRE(deque[i] == i * 10);&#10;        }&#10;    }&#10;    &#10;    SECTION(&quot;Iterator with mixed push operations&quot;) {&#10;        Deque&lt;int&gt; deque;&#10;        &#10;        // Create a pattern: push_front some, push_back some&#10;        for (int i = 0; i &lt; 5; ++i) {&#10;            deque.push_front(-i - 1);  // -1, -2, -3, -4, -5&#10;            deque.push_back(i + 1);    //  1,  2,  3,  4,  5&#10;        }&#10;        &#10;        // Expected order: [-5, -4, -3, -2, -1, 1, 2, 3, 4, 5]&#10;        std::vector&lt;int&gt; expected = {-5, -4, -3, -2, -1, 1, 2, 3, 4, 5};&#10;        &#10;        int index = 0;&#10;        for (auto it = deque.begin(); it.current_array != nullptr; ++it) {&#10;            REQUIRE(*it == expected[index]);&#10;            ++index;&#10;        }&#10;        REQUIRE(index == expected.size());&#10;    }&#10;    &#10;    SECTION(&quot;Range-based for loop&quot;) {&#10;        Deque&lt;std::string&gt; deque = {&quot;hello&quot;, &quot;world&quot;, &quot;test&quot;};&#10;        &#10;        std::vector&lt;std::string&gt; collected;&#10;        for (const auto&amp; item : deque) {&#10;            collected.push_back(item);&#10;        }&#10;        &#10;        REQUIRE(collected.size() == 3);&#10;        REQUIRE(collected[0] == &quot;hello&quot;);&#10;        REQUIRE(collected[1] == &quot;world&quot;);&#10;        REQUIRE(collected[2] == &quot;test&quot;);&#10;    }&#10;    &#10;    SECTION(&quot;Empty deque iterator&quot;) {&#10;        Deque&lt;int&gt; deque;&#10;        &#10;        auto begin_it = deque.begin();&#10;        auto end_it = deque.end();&#10;        &#10;        // For empty deque, begin should point to end immediately&#10;        REQUIRE(begin_it.current_array != nullptr); // Points to the initial FixedArray&#10;        REQUIRE(end_it.current_array == nullptr);&#10;        &#10;        // Incrementing begin should reach end quickly&#10;        ++begin_it;&#10;        REQUIRE(begin_it.current_array == nullptr);&#10;    }&#10;    &#10;    SECTION(&quot;Iterator prev() method&quot;) {&#10;        Deque&lt;int&gt; deque = {1, 2, 3, 4, 5};&#10;        &#10;        // Start from end and work backwards using prev()&#10;        auto it = deque.end().prev();&#10;        REQUIRE(*it == 5);&#10;        &#10;        it = it.prev();&#10;        REQUIRE(*it == 4);&#10;        &#10;        it = it.prev();&#10;        REQUIRE(*it == 3);&#10;        &#10;        it = it.prev();&#10;        REQUIRE(*it == 2);&#10;        &#10;        it = it.prev();&#10;        REQUIRE(*it == 1);&#10;    }&#10;    &#10;    SECTION(&quot;Iterator boundary conditions&quot;) {&#10;        Deque&lt;int&gt; deque;&#10;        &#10;        // Test with exactly one element&#10;        deque.push_back(42);&#10;        auto it = deque.begin();&#10;        REQUIRE(*it == 42);&#10;        &#10;        ++it;&#10;        REQUIRE(it.current_array == nullptr); // Should be at end&#10;        &#10;        // Test prev from end&#10;        it = deque.end().prev();&#10;        REQUIRE(*it == 42);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>